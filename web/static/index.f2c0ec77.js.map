{"mappings":"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","sources":["node_modules/@parcel/runtime-browser-hmr/lib/runtime-93f4565fec7cd4ea.js","index.mjs","node_modules/luaparse/luaparse.js","node_modules/luamin/luamin.js","node_modules/luamin/node_modules/luaparse/luaparse.js","node_modules/@parcel/transformer-js/src/esmodule-helpers.js"],"sourcesContent":["var HMR_HOST = null;var HMR_PORT = null;var HMR_SECURE = false;var HMR_ENV_HASH = \"d6ea1d42532a7575\";var HMR_USE_SSE = false;module.bundle.HMR_BUNDLE_ID = \"0906654af2c0ec77\";\"use strict\";\n\n/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */\n/*::\nimport type {\n  HMRAsset,\n  HMRMessage,\n} from '@parcel/reporter-dev-server/src/HMRServer.js';\ninterface ParcelRequire {\n  (string): mixed;\n  cache: {|[string]: ParcelModule|};\n  hotData: {|[string]: mixed|};\n  Module: any;\n  parent: ?ParcelRequire;\n  isParcelRequire: true;\n  modules: {|[string]: [Function, {|[string]: string|}]|};\n  HMR_BUNDLE_ID: string;\n  root: ParcelRequire;\n}\ninterface ParcelModule {\n  hot: {|\n    data: mixed,\n    accept(cb: (Function) => void): void,\n    dispose(cb: (mixed) => void): void,\n    // accept(deps: Array<string> | string, cb: (Function) => void): void,\n    // decline(): void,\n    _acceptCallbacks: Array<(Function) => void>,\n    _disposeCallbacks: Array<(mixed) => void>,\n  |};\n}\ninterface ExtensionContext {\n  runtime: {|\n    reload(): void,\n    getURL(url: string): string;\n    getManifest(): {manifest_version: number, ...};\n  |};\n}\ndeclare var module: {bundle: ParcelRequire, ...};\ndeclare var HMR_HOST: string;\ndeclare var HMR_PORT: string;\ndeclare var HMR_ENV_HASH: string;\ndeclare var HMR_SECURE: boolean;\ndeclare var HMR_USE_SSE: boolean;\ndeclare var chrome: ExtensionContext;\ndeclare var browser: ExtensionContext;\ndeclare var __parcel__import__: (string) => Promise<void>;\ndeclare var __parcel__importScripts__: (string) => Promise<void>;\ndeclare var globalThis: typeof self;\ndeclare var ServiceWorkerGlobalScope: Object;\n*/\nvar OVERLAY_ID = '__parcel__error__overlay__';\nvar OldModule = module.bundle.Module;\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData[moduleName],\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n  module.bundle.hotData[moduleName] = undefined;\n}\nmodule.bundle.Module = Module;\nmodule.bundle.hotData = {};\nvar checkedAssets /*: {|[string]: boolean|} */, disposedAssets /*: {|[string]: boolean|} */, assetsToDispose /*: Array<[ParcelRequire, string]> */, assetsToAccept /*: Array<[ParcelRequire, string]> */;\nfunction getHostname() {\n  return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');\n}\nfunction getPort() {\n  return HMR_PORT || location.port;\n}\n\n// eslint-disable-next-line no-redeclare\nvar parent = module.bundle.parent;\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = getHostname();\n  var port = getPort();\n  var protocol = HMR_SECURE || location.protocol == 'https:' && !['localhost', '127.0.0.1', '0.0.0.0'].includes(hostname) ? 'wss' : 'ws';\n  var ws;\n  if (HMR_USE_SSE) {\n    ws = new EventSource('/__parcel_hmr');\n  } else {\n    try {\n      ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');\n    } catch (err) {\n      if (err.message) {\n        console.error(err.message);\n      }\n      ws = {};\n    }\n  }\n\n  // Web extension context\n  var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;\n\n  // Safari doesn't support sourceURL in error stacks.\n  // eval may also be disabled via CSP, so do a quick check.\n  var supportsSourceURL = false;\n  try {\n    (0, eval)('throw new Error(\"test\"); //# sourceURL=test.js');\n  } catch (err) {\n    supportsSourceURL = err.stack.includes('test.js');\n  }\n\n  // $FlowFixMe\n  ws.onmessage = async function (event /*: {data: string, ...} */) {\n    checkedAssets = {} /*: {|[string]: boolean|} */;\n    disposedAssets = {} /*: {|[string]: boolean|} */;\n    assetsToAccept = [];\n    assetsToDispose = [];\n    var data /*: HMRMessage */ = JSON.parse(event.data);\n    if (data.type === 'reload') {\n      fullReload();\n    } else if (data.type === 'update') {\n      // Remove error overlay if there is one\n      if (typeof document !== 'undefined') {\n        removeErrorOverlay();\n      }\n      let assets = data.assets.filter(asset => asset.envHash === HMR_ENV_HASH);\n\n      // Handle HMR Update\n      let handled = assets.every(asset => {\n        return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);\n      });\n      if (handled) {\n        console.clear();\n\n        // Dispatch custom event so other runtimes (e.g React Refresh) are aware.\n        if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') {\n          window.dispatchEvent(new CustomEvent('parcelhmraccept'));\n        }\n        await hmrApplyUpdates(assets);\n        hmrDisposeQueue();\n\n        // Run accept callbacks. This will also re-execute other disposed assets in topological order.\n        let processedAssets = {};\n        for (let i = 0; i < assetsToAccept.length; i++) {\n          let id = assetsToAccept[i][1];\n          if (!processedAssets[id]) {\n            hmrAccept(assetsToAccept[i][0], id);\n            processedAssets[id] = true;\n          }\n        }\n      } else fullReload();\n    }\n    if (data.type === 'error') {\n      // Log parcel errors to console\n      for (let ansiDiagnostic of data.diagnostics.ansi) {\n        let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;\n        console.error(' [parcel]: ' + ansiDiagnostic.message + '\\n' + stack + '\\n\\n' + ansiDiagnostic.hints.join('\\n'));\n      }\n      if (typeof document !== 'undefined') {\n        // Render the fancy html overlay\n        removeErrorOverlay();\n        var overlay = createErrorOverlay(data.diagnostics.html);\n        // $FlowFixMe\n        document.body.appendChild(overlay);\n      }\n    }\n  };\n  if (ws instanceof WebSocket) {\n    ws.onerror = function (e) {\n      if (e.message) {\n        console.error(e.message);\n      }\n    };\n    ws.onclose = function () {\n      console.warn('[parcel]  Connection to the HMR server was lost');\n    };\n  }\n}\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n    console.log('[parcel]  Error resolved');\n  }\n}\nfunction createErrorOverlay(diagnostics) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n  let errorHTML = '<div style=\"background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;\">';\n  for (let diagnostic of diagnostics) {\n    let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame) => {\n      return `${p}\n<a href=\"/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}\" style=\"text-decoration: underline; color: #888\" onclick=\"fetch(this.href); return false\">${frame.location}</a>\n${frame.code}`;\n    }, '') : diagnostic.stack;\n    errorHTML += `\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n           ${diagnostic.message}\n        </div>\n        <pre>${stack}</pre>\n        <div>\n          ${diagnostic.hints.map(hint => '<div> ' + hint + '</div>').join('')}\n        </div>\n        ${diagnostic.documentation ? `<div> <a style=\"color: violet\" href=\"${diagnostic.documentation}\" target=\"_blank\">Learn more</a></div>` : ''}\n      </div>\n    `;\n  }\n  errorHTML += '</div>';\n  overlay.innerHTML = errorHTML;\n  return overlay;\n}\nfunction fullReload() {\n  if ('reload' in location) {\n    location.reload();\n  } else if (extCtx && extCtx.runtime && extCtx.runtime.reload) {\n    extCtx.runtime.reload();\n  }\n}\nfunction getParents(bundle, id) /*: Array<[ParcelRequire, string]> */{\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n  var parents = [];\n  var k, d, dep;\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {\n        parents.push([bundle, k]);\n      }\n    }\n  }\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n  return parents;\n}\nfunction updateLink(link) {\n  var href = link.getAttribute('href');\n  if (!href) {\n    return;\n  }\n  var newLink = link.cloneNode();\n  newLink.onload = function () {\n    if (link.parentNode !== null) {\n      // $FlowFixMe\n      link.parentNode.removeChild(link);\n    }\n  };\n  newLink.setAttribute('href',\n  // $FlowFixMe\n  href.split('?')[0] + '?' + Date.now());\n  // $FlowFixMe\n  link.parentNode.insertBefore(newLink, link.nextSibling);\n}\nvar cssTimeout = null;\nfunction reloadCSS() {\n  if (cssTimeout) {\n    return;\n  }\n  cssTimeout = setTimeout(function () {\n    var links = document.querySelectorAll('link[rel=\"stylesheet\"]');\n    for (var i = 0; i < links.length; i++) {\n      // $FlowFixMe[incompatible-type]\n      var href /*: string */ = links[i].getAttribute('href');\n      var hostname = getHostname();\n      var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\\\/\\\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());\n      var absolute = /^https?:\\/\\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;\n      if (!absolute) {\n        updateLink(links[i]);\n      }\n    }\n    cssTimeout = null;\n  }, 50);\n}\nfunction hmrDownload(asset) {\n  if (asset.type === 'js') {\n    if (typeof document !== 'undefined') {\n      let script = document.createElement('script');\n      script.src = asset.url + '?t=' + Date.now();\n      if (asset.outputFormat === 'esmodule') {\n        script.type = 'module';\n      }\n      return new Promise((resolve, reject) => {\n        var _document$head;\n        script.onload = () => resolve(script);\n        script.onerror = reject;\n        (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);\n      });\n    } else if (typeof importScripts === 'function') {\n      // Worker scripts\n      if (asset.outputFormat === 'esmodule') {\n        return __parcel__import__(asset.url + '?t=' + Date.now());\n      } else {\n        return new Promise((resolve, reject) => {\n          try {\n            __parcel__importScripts__(asset.url + '?t=' + Date.now());\n            resolve();\n          } catch (err) {\n            reject(err);\n          }\n        });\n      }\n    }\n  }\n}\nasync function hmrApplyUpdates(assets) {\n  global.parcelHotUpdate = Object.create(null);\n  let scriptsToRemove;\n  try {\n    // If sourceURL comments aren't supported in eval, we need to load\n    // the update from the dev server over HTTP so that stack traces\n    // are correct in errors/logs. This is much slower than eval, so\n    // we only do it if needed (currently just Safari).\n    // https://bugs.webkit.org/show_bug.cgi?id=137297\n    // This path is also taken if a CSP disallows eval.\n    if (!supportsSourceURL) {\n      let promises = assets.map(asset => {\n        var _hmrDownload;\n        return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch(err => {\n          // Web extension fix\n          if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {\n            extCtx.runtime.reload();\n            return;\n          }\n          throw err;\n        });\n      });\n      scriptsToRemove = await Promise.all(promises);\n    }\n    assets.forEach(function (asset) {\n      hmrApply(module.bundle.root, asset);\n    });\n  } finally {\n    delete global.parcelHotUpdate;\n    if (scriptsToRemove) {\n      scriptsToRemove.forEach(script => {\n        if (script) {\n          var _document$head2;\n          (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);\n        }\n      });\n    }\n  }\n}\nfunction hmrApply(bundle /*: ParcelRequire */, asset /*:  HMRAsset */) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (asset.type === 'css') {\n    reloadCSS();\n  } else if (asset.type === 'js') {\n    let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];\n    if (deps) {\n      if (modules[asset.id]) {\n        // Remove dependencies that are removed and will become orphaned.\n        // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.\n        let oldDeps = modules[asset.id][1];\n        for (let dep in oldDeps) {\n          if (!deps[dep] || deps[dep] !== oldDeps[dep]) {\n            let id = oldDeps[dep];\n            let parents = getParents(module.bundle.root, id);\n            if (parents.length === 1) {\n              hmrDelete(module.bundle.root, id);\n            }\n          }\n        }\n      }\n      if (supportsSourceURL) {\n        // Global eval. We would use `new Function` here but browser\n        // support for source maps is better with eval.\n        (0, eval)(asset.output);\n      }\n\n      // $FlowFixMe\n      let fn = global.parcelHotUpdate[asset.id];\n      modules[asset.id] = [fn, deps];\n    }\n\n    // Always traverse to the parent bundle, even if we already replaced the asset in this bundle.\n    // This is required in case modules are duplicated. We need to ensure all instances have the updated code.\n    if (bundle.parent) {\n      hmrApply(bundle.parent, asset);\n    }\n  }\n}\nfunction hmrDelete(bundle, id) {\n  let modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (modules[id]) {\n    // Collect dependencies that will become orphaned when this module is deleted.\n    let deps = modules[id][1];\n    let orphans = [];\n    for (let dep in deps) {\n      let parents = getParents(module.bundle.root, deps[dep]);\n      if (parents.length === 1) {\n        orphans.push(deps[dep]);\n      }\n    }\n\n    // Delete the module. This must be done before deleting dependencies in case of circular dependencies.\n    delete modules[id];\n    delete bundle.cache[id];\n\n    // Now delete the orphans.\n    orphans.forEach(id => {\n      hmrDelete(module.bundle.root, id);\n    });\n  } else if (bundle.parent) {\n    hmrDelete(bundle.parent, id);\n  }\n}\nfunction hmrAcceptCheck(bundle /*: ParcelRequire */, id /*: string */, depsByBundle /*: ?{ [string]: { [string]: string } }*/) {\n  if (hmrAcceptCheckOne(bundle, id, depsByBundle)) {\n    return true;\n  }\n\n  // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.\n  let parents = getParents(module.bundle.root, id);\n  let accepted = false;\n  while (parents.length > 0) {\n    let v = parents.shift();\n    let a = hmrAcceptCheckOne(v[0], v[1], null);\n    if (a) {\n      // If this parent accepts, stop traversing upward, but still consider siblings.\n      accepted = true;\n    } else {\n      // Otherwise, queue the parents in the next level upward.\n      let p = getParents(module.bundle.root, v[1]);\n      if (p.length === 0) {\n        // If there are no parents, then we've reached an entry without accepting. Reload.\n        accepted = false;\n        break;\n      }\n      parents.push(...p);\n    }\n  }\n  return accepted;\n}\nfunction hmrAcceptCheckOne(bundle /*: ParcelRequire */, id /*: string */, depsByBundle /*: ?{ [string]: { [string]: string } }*/) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {\n    // If we reached the root bundle without finding where the asset should go,\n    // there's nothing to do. Mark as \"accepted\" so we don't reload the page.\n    if (!bundle.parent) {\n      return true;\n    }\n    return hmrAcceptCheck(bundle.parent, id, depsByBundle);\n  }\n  if (checkedAssets[id]) {\n    return true;\n  }\n  checkedAssets[id] = true;\n  var cached = bundle.cache[id];\n  assetsToDispose.push([bundle, id]);\n  if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {\n    assetsToAccept.push([bundle, id]);\n    return true;\n  }\n}\nfunction hmrDisposeQueue() {\n  // Dispose all old assets.\n  for (let i = 0; i < assetsToDispose.length; i++) {\n    let id = assetsToDispose[i][1];\n    if (!disposedAssets[id]) {\n      hmrDispose(assetsToDispose[i][0], id);\n      disposedAssets[id] = true;\n    }\n  }\n  assetsToDispose = [];\n}\nfunction hmrDispose(bundle /*: ParcelRequire */, id /*: string */) {\n  var cached = bundle.cache[id];\n  bundle.hotData[id] = {};\n  if (cached && cached.hot) {\n    cached.hot.data = bundle.hotData[id];\n  }\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData[id]);\n    });\n  }\n  delete bundle.cache[id];\n}\nfunction hmrAccept(bundle /*: ParcelRequire */, id /*: string */) {\n  // Execute the module.\n  bundle(id);\n\n  // Run the accept callbacks in the new version of the module.\n  var cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    let assetsToAlsoAccept = [];\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      let additionalAssets = cb(function () {\n        return getParents(module.bundle.root, id);\n      });\n      if (Array.isArray(additionalAssets) && additionalAssets.length) {\n        assetsToAlsoAccept.push(...additionalAssets);\n      }\n    });\n    if (assetsToAlsoAccept.length) {\n      let handled = assetsToAlsoAccept.every(function (a) {\n        return hmrAcceptCheck(a[0], a[1]);\n      });\n      if (!handled) {\n        return fullReload();\n      }\n      hmrDisposeQueue();\n    }\n  }\n}","import * as luaparse from 'luaparse';\nimport luamin from 'luamin';\n\n// Attach `luamin` and `luaparse` to the `window` object\nwindow.luamin = {\n  parse: luaparse.parse,\n  minify: luamin.minify,\n};\n","/* global exports:true, module:true, require:true, define:true, global:true */\n\n(function (root, name, factory) {\n  'use strict';\n\n  // Used to determine if values are of the language type `Object`\n  var objectTypes = {\n        'function': true\n      , 'object': true\n    }\n    // Detect free variable `exports`\n    , freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports\n    // Detect free variable `module`\n    , freeModule = objectTypes[typeof module] && module && !module.nodeType && module\n    // Detect free variable `global`, from Node.js or Browserified code, and\n    // use it as `window`\n    , freeGlobal = freeExports && freeModule && typeof global === 'object' && global\n    // Detect the popular CommonJS extension `module.exports`\n    , moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  /* istanbul ignore else */\n  if (freeGlobal && (freeGlobal.global === freeGlobal ||\n                     /* istanbul ignore next */ freeGlobal.window === freeGlobal ||\n                     /* istanbul ignore next */ freeGlobal.self === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  // Some AMD build optimizers, like r.js, check for specific condition\n  // patterns like the following:\n  /* istanbul ignore if */\n  if (typeof define === 'function' &&\n      /* istanbul ignore next */ typeof define.amd === 'object' &&\n      /* istanbul ignore next */ define.amd) {\n    // defined as an anonymous module.\n    define(['exports'], factory);\n    // In case the source has been processed and wrapped in a define module use\n    // the supplied `exports` object.\n    if (freeExports && moduleExports) factory(freeModule.exports);\n  }\n  // check for `exports` after `define` in case a build optimizer adds an\n  // `exports` object\n  else /* istanbul ignore else */ if (freeExports && freeModule) {\n    // in Node.js or RingoJS v0.8.0+\n    /* istanbul ignore else */\n    if (moduleExports) factory(freeModule.exports);\n    // in RingoJS v0.7.0-\n    else factory(freeExports);\n  }\n  // in a browser or Rhino\n  else {\n    factory((root[name] = {}));\n  }\n}(this, 'luaparse', function (exports) {\n  'use strict';\n\n  exports.version = \"0.3.1\";\n\n  var input, options, length, features, encodingMode;\n\n  // Options can be set either globally on the parser object through\n  // defaultOptions, or during the parse call.\n  var defaultOptions = exports.defaultOptions = {\n    // Explicitly tell the parser when the input ends.\n      wait: false\n    // Store comments as an array in the chunk object.\n    , comments: true\n    // Track identifier scopes by adding an isLocal attribute to each\n    // identifier-node.\n    , scope: false\n    // Store location information on each syntax node as\n    // `loc: { start: { line, column }, end: { line, column } }`.\n    , locations: false\n    // Store the start and end character locations on each syntax node as\n    // `range: [start, end]`.\n    , ranges: false\n    // A callback which will be invoked when a syntax node has been completed.\n    // The node which has been created will be passed as the only parameter.\n    , onCreateNode: null\n    // A callback which will be invoked when a new scope is created.\n    , onCreateScope: null\n    // A callback which will be invoked when the current scope is destroyed.\n    , onDestroyScope: null\n    // A callback which will be invoked when a local variable is declared in the current scope.\n    // The variable's name will be passed as the only parameter\n    , onLocalDeclaration: null\n    // The version of Lua targeted by the parser (string; allowed values are\n    // '5.1', '5.2', '5.3').\n    , luaVersion: '5.1'\n    // Encoding mode: how to interpret code units higher than U+007F in input\n    , encodingMode: 'none'\n  };\n\n  function encodeUTF8(codepoint, highMask) {\n    highMask = highMask || 0;\n\n    if (codepoint < 0x80) {\n      return String.fromCharCode(codepoint);\n    } else if (codepoint < 0x800) {\n      return String.fromCharCode(\n        highMask | 0xc0 |  (codepoint >>  6)        ,\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else if (codepoint < 0x10000) {\n      return String.fromCharCode(\n        highMask | 0xe0 |  (codepoint >> 12)        ,\n        highMask | 0x80 | ((codepoint >>  6) & 0x3f),\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else /* istanbul ignore else */ if (codepoint < 0x110000) {\n      return String.fromCharCode(\n        highMask | 0xf0 |  (codepoint >> 18)        ,\n        highMask | 0x80 | ((codepoint >> 12) & 0x3f),\n        highMask | 0x80 | ((codepoint >>  6) & 0x3f),\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else {\n      // TODO: Lua 5.4 allows up to six-byte sequences, as in UTF-8:1993\n      return null;\n    }\n  }\n\n  function toHex(num, digits) {\n    var result = num.toString(16);\n    while (result.length < digits)\n      result = '0' + result;\n    return result;\n  }\n\n  function checkChars(rx) {\n    return function (s) {\n      var m = rx.exec(s);\n      if (!m)\n        return s;\n      raise(null, errors.invalidCodeUnit, toHex(m[0].charCodeAt(0), 4).toUpperCase());\n    };\n  }\n\n  var encodingModes = {\n    // `pseudo-latin1` encoding mode: assume the input was decoded with the latin1 encoding\n    // WARNING: latin1 does **NOT** mean cp1252 here like in the bone-headed WHATWG standard;\n    // it means true ISO/IEC 8859-1 identity-mapped to Basic Latin and Latin-1 Supplement blocks\n    'pseudo-latin1': {\n      fixup: checkChars(/[^\\x00-\\xff]/),\n      encodeByte: function (value) {\n        if (value === null)\n          return '';\n        return String.fromCharCode(value);\n      },\n      encodeUTF8: function (codepoint) {\n        return encodeUTF8(codepoint);\n      },\n    },\n\n    // `x-user-defined` encoding mode: assume the input was decoded with the WHATWG `x-user-defined` encoding\n    'x-user-defined': {\n      fixup: checkChars(/[^\\x00-\\x7f\\uf780-\\uf7ff]/),\n      encodeByte: function (value) {\n        if (value === null)\n          return '';\n        if (value >= 0x80)\n          return String.fromCharCode(value | 0xf700);\n        return String.fromCharCode(value);\n      },\n      encodeUTF8: function (codepoint) {\n        return encodeUTF8(codepoint, 0xf700);\n      }\n    },\n\n    // `none` encoding mode: disregard intrepretation of string literals, leave identifiers as-is\n    'none': {\n      discardStrings: true,\n      fixup: function (s) {\n        return s;\n      },\n      encodeByte: function (value) {\n        return '';\n      },\n      encodeUTF8: function (codepoint) {\n        return '';\n      }\n    }\n  };\n\n  // The available tokens expressed as enum flags so they can be checked with\n  // bitwise operations.\n\n  var EOF = 1, StringLiteral = 2, Keyword = 4, Identifier = 8\n    , NumericLiteral = 16, Punctuator = 32, BooleanLiteral = 64\n    , NilLiteral = 128, VarargLiteral = 256;\n\n  exports.tokenTypes = { EOF: EOF, StringLiteral: StringLiteral\n    , Keyword: Keyword, Identifier: Identifier, NumericLiteral: NumericLiteral\n    , Punctuator: Punctuator, BooleanLiteral: BooleanLiteral\n    , NilLiteral: NilLiteral, VarargLiteral: VarargLiteral\n  };\n\n  // As this parser is a bit different from luas own, the error messages\n  // will be different in some situations.\n\n  var errors = exports.errors = {\n      unexpected: 'unexpected %1 \\'%2\\' near \\'%3\\''\n    , unexpectedEOF: 'unexpected symbol near \\'<eof>\\''\n    , expected: '\\'%1\\' expected near \\'%2\\''\n    , expectedToken: '%1 expected near \\'%2\\''\n    , unfinishedString: 'unfinished string near \\'%1\\''\n    , malformedNumber: 'malformed number near \\'%1\\''\n    , decimalEscapeTooLarge: 'decimal escape too large near \\'%1\\''\n    , invalidEscape: 'invalid escape sequence near \\'%1\\''\n    , hexadecimalDigitExpected: 'hexadecimal digit expected near \\'%1\\''\n    , braceExpected: 'missing \\'%1\\' near \\'%2\\''\n    , tooLargeCodepoint: 'UTF-8 value too large near \\'%1\\''\n    , unfinishedLongString: 'unfinished long string (starting at line %1) near \\'%2\\''\n    , unfinishedLongComment: 'unfinished long comment (starting at line %1) near \\'%2\\''\n    , ambiguousSyntax: 'ambiguous syntax (function call x new statement) near \\'%1\\''\n    , noLoopToBreak: 'no loop to break near \\'%1\\''\n    , labelAlreadyDefined: 'label \\'%1\\' already defined on line %2'\n    , labelNotVisible: 'no visible label \\'%1\\' for <goto>'\n    , gotoJumpInLocalScope: '<goto %1> jumps into the scope of local \\'%2\\''\n    , cannotUseVararg: 'cannot use \\'...\\' outside a vararg function near \\'%1\\''\n    , invalidCodeUnit: 'code unit U+%1 is not allowed in the current encoding mode'\n  };\n\n  // ### Abstract Syntax Tree\n  //\n  // The default AST structure is inspired by the Mozilla Parser API but can\n  // easily be customized by overriding these functions.\n\n  var ast = exports.ast = {\n      labelStatement: function(label) {\n      return {\n          type: 'LabelStatement'\n        , label: label\n      };\n    }\n\n    , breakStatement: function() {\n      return {\n          type: 'BreakStatement'\n      };\n    }\n\n    , gotoStatement: function(label) {\n      return {\n          type: 'GotoStatement'\n        , label: label\n      };\n    }\n\n    , returnStatement: function(args) {\n      return {\n          type: 'ReturnStatement'\n        , 'arguments': args\n      };\n    }\n\n    , ifStatement: function(clauses) {\n      return {\n          type: 'IfStatement'\n        , clauses: clauses\n      };\n    }\n    , ifClause: function(condition, body) {\n      return {\n          type: 'IfClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseifClause: function(condition, body) {\n      return {\n          type: 'ElseifClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseClause: function(body) {\n      return {\n          type: 'ElseClause'\n        , body: body\n      };\n    }\n\n    , whileStatement: function(condition, body) {\n      return {\n          type: 'WhileStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , doStatement: function(body) {\n      return {\n          type: 'DoStatement'\n        , body: body\n      };\n    }\n\n    , repeatStatement: function(condition, body) {\n      return {\n          type: 'RepeatStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , localStatement: function(variables, init) {\n      return {\n          type: 'LocalStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , assignmentStatement: function(variables, init) {\n      return {\n          type: 'AssignmentStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , callStatement: function(expression) {\n      return {\n          type: 'CallStatement'\n        , expression: expression\n      };\n    }\n\n    , functionStatement: function(identifier, parameters, isLocal, body) {\n      return {\n          type: 'FunctionDeclaration'\n        , identifier: identifier\n        , isLocal: isLocal\n        , parameters: parameters\n        , body: body\n      };\n    }\n\n    , forNumericStatement: function(variable, start, end, step, body) {\n      return {\n          type: 'ForNumericStatement'\n        , variable: variable\n        , start: start\n        , end: end\n        , step: step\n        , body: body\n      };\n    }\n\n    , forGenericStatement: function(variables, iterators, body) {\n      return {\n          type: 'ForGenericStatement'\n        , variables: variables\n        , iterators: iterators\n        , body: body\n      };\n    }\n\n    , chunk: function(body) {\n      return {\n          type: 'Chunk'\n        , body: body\n      };\n    }\n\n    , identifier: function(name) {\n      return {\n          type: 'Identifier'\n        , name: name\n      };\n    }\n\n    , literal: function(type, value, raw) {\n      type = (type === StringLiteral) ? 'StringLiteral'\n        : (type === NumericLiteral) ? 'NumericLiteral'\n        : (type === BooleanLiteral) ? 'BooleanLiteral'\n        : (type === NilLiteral) ? 'NilLiteral'\n        : 'VarargLiteral';\n\n      return {\n          type: type\n        , value: value\n        , raw: raw\n      };\n    }\n\n    , tableKey: function(key, value) {\n      return {\n          type: 'TableKey'\n        , key: key\n        , value: value\n      };\n    }\n    , tableKeyString: function(key, value) {\n      return {\n          type: 'TableKeyString'\n        , key: key\n        , value: value\n      };\n    }\n    , tableValue: function(value) {\n      return {\n          type: 'TableValue'\n        , value: value\n      };\n    }\n\n\n    , tableConstructorExpression: function(fields) {\n      return {\n          type: 'TableConstructorExpression'\n        , fields: fields\n      };\n    }\n    , binaryExpression: function(operator, left, right) {\n      var type = ('and' === operator || 'or' === operator) ?\n        'LogicalExpression' :\n        'BinaryExpression';\n\n      return {\n          type: type\n        , operator: operator\n        , left: left\n        , right: right\n      };\n    }\n    , unaryExpression: function(operator, argument) {\n      return {\n          type: 'UnaryExpression'\n        , operator: operator\n        , argument: argument\n      };\n    }\n    , memberExpression: function(base, indexer, identifier) {\n      return {\n          type: 'MemberExpression'\n        , indexer: indexer\n        , identifier: identifier\n        , base: base\n      };\n    }\n\n    , indexExpression: function(base, index) {\n      return {\n          type: 'IndexExpression'\n        , base: base\n        , index: index\n      };\n    }\n\n    , callExpression: function(base, args) {\n      return {\n          type: 'CallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , tableCallExpression: function(base, args) {\n      return {\n          type: 'TableCallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , stringCallExpression: function(base, argument) {\n      return {\n          type: 'StringCallExpression'\n        , base: base\n        , argument: argument\n      };\n    }\n\n    , comment: function(value, raw) {\n      return {\n          type: 'Comment'\n        , value: value\n        , raw: raw\n      };\n    }\n  };\n\n  // Wrap up the node object.\n\n  function finishNode(node) {\n    // Pop a `Marker` off the location-array and attach its location data.\n    if (trackLocations) {\n      var location = locations.pop();\n      location.complete();\n      location.bless(node);\n    }\n    if (options.onCreateNode) options.onCreateNode(node);\n    return node;\n  }\n\n\n  // Helpers\n  // -------\n\n  var slice = Array.prototype.slice\n    , toString = Object.prototype.toString\n    ;\n\n  var indexOf = /* istanbul ignore next */ function (array, element) {\n    for (var i = 0, length = array.length; i < length; ++i) {\n      if (array[i] === element) return i;\n    }\n    return -1;\n  };\n\n  /* istanbul ignore else */\n  if (Array.prototype.indexOf)\n    indexOf = function (array, element) {\n      return array.indexOf(element);\n    };\n\n  // Iterate through an array of objects and return the index of an object\n  // with a matching property.\n\n  function indexOfObject(array, property, element) {\n    for (var i = 0, length = array.length; i < length; ++i) {\n      if (array[i][property] === element) return i;\n    }\n    return -1;\n  }\n\n  // A sprintf implementation using %index (beginning at 1) to input\n  // arguments in the format string.\n  //\n  // Example:\n  //\n  //     // Unexpected function in token\n  //     sprintf('Unexpected %2 in %1.', 'token', 'function');\n\n  function sprintf(format) {\n    var args = slice.call(arguments, 1);\n    format = format.replace(/%(\\d)/g, function (match, index) {\n      return '' + args[index - 1] || /* istanbul ignore next */ '';\n    });\n    return format;\n  }\n\n  // Polyfill for `Object.assign`.\n\n  var assign = /* istanbul ignore next */ function (dest) {\n    var args = slice.call(arguments, 1)\n      , src, prop;\n\n    for (var i = 0, length = args.length; i < length; ++i) {\n      src = args[i];\n      for (prop in src)\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(src, prop)) {\n          dest[prop] = src[prop];\n        }\n    }\n\n    return dest;\n  };\n\n  /* istanbul ignore else */\n  if (Object.assign)\n    assign = Object.assign;\n\n  // ### Error functions\n\n  exports.SyntaxError = SyntaxError;\n\n  // XXX: Eliminate this function and change the error type to be different from SyntaxError.\n  // This will unfortunately be a breaking change, because some downstream users depend\n  // on the error thrown being an instance of SyntaxError. For example, the Ace editor:\n  // <https://github.com/ajaxorg/ace/blob/4c7e5eb3f5d5ca9434847be51834a4e41661b852/lib/ace/mode/lua_worker.js#L55>\n\n  function fixupError(e) {\n    /* istanbul ignore if */\n    if (!Object.create)\n      return e;\n    return Object.create(e, {\n      'line': { 'writable': true, value: e.line },\n      'index': { 'writable': true, value: e.index },\n      'column': { 'writable': true, value: e.column }\n    });\n  }\n\n  // #### Raise an exception.\n  //\n  // Raise an exception by passing a token, a string format and its paramters.\n  //\n  // The passed tokens location will automatically be added to the error\n  // message if it exists, if not it will default to the lexers current\n  // position.\n  //\n  // Example:\n  //\n  //     // [1:0] expected [ near (\n  //     raise(token, \"expected %1 near %2\", '[', token.value);\n\n  function raise(token) {\n    var message = sprintf.apply(null, slice.call(arguments, 1))\n      , error, col;\n\n    if (token === null || typeof token.line === 'undefined') {\n      col = index - lineStart + 1;\n      error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', line, col, message)));\n      error.index = index;\n      error.line = line;\n      error.column = col;\n    } else {\n      col = token.range[0] - token.lineStart;\n      error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', token.line, col, message)));\n      error.line = token.line;\n      error.index = token.range[0];\n      error.column = col;\n    }\n    throw error;\n  }\n\n  function tokenValue(token) {\n    var raw = input.slice(token.range[0], token.range[1]);\n    if (raw)\n      return raw;\n    return token.value;\n  }\n\n  // #### Raise an unexpected token error.\n  //\n  // Example:\n  //\n  //     // expected <name> near '0'\n  //     raiseUnexpectedToken('<name>', token);\n\n  function raiseUnexpectedToken(type, token) {\n    raise(token, errors.expectedToken, type, tokenValue(token));\n  }\n\n  // #### Raise a general unexpected error\n  //\n  // Usage should pass either a token object or a symbol string which was\n  // expected. We can also specify a nearby token such as <eof>, this will\n  // default to the currently active token.\n  //\n  // Example:\n  //\n  //     // Unexpected symbol 'end' near '<eof>'\n  //     unexpected(token);\n  //\n  // If there's no token in the buffer it means we have reached <eof>.\n\n  function unexpected(found) {\n    var near = tokenValue(lookahead);\n    if ('undefined' !== typeof found.type) {\n      var type;\n      switch (found.type) {\n        case StringLiteral:   type = 'string';      break;\n        case Keyword:         type = 'keyword';     break;\n        case Identifier:      type = 'identifier';  break;\n        case NumericLiteral:  type = 'number';      break;\n        case Punctuator:      type = 'symbol';      break;\n        case BooleanLiteral:  type = 'boolean';     break;\n        case NilLiteral:\n          return raise(found, errors.unexpected, 'symbol', 'nil', near);\n        case EOF:\n          return raise(found, errors.unexpectedEOF);\n      }\n      return raise(found, errors.unexpected, type, tokenValue(found), near);\n    }\n    return raise(found, errors.unexpected, 'symbol', found, near);\n  }\n\n  // Lexer\n  // -----\n  //\n  // The lexer, or the tokenizer reads the input string character by character\n  // and derives a token left-right. To be as efficient as possible the lexer\n  // prioritizes the common cases such as identifiers. It also works with\n  // character codes instead of characters as string comparisons was the\n  // biggest bottleneck of the parser.\n  //\n  // If `options.comments` is enabled, all comments encountered will be stored\n  // in an array which later will be appended to the chunk object. If disabled,\n  // they will simply be disregarded.\n  //\n  // When the lexer has derived a valid token, it will be returned as an object\n  // containing its value and as well as its position in the input string (this\n  // is always enabled to provide proper debug messages).\n  //\n  // `lex()` starts lexing and returns the following token in the stream.\n\n  var index\n    , token\n    , previousToken\n    , lookahead\n    , comments\n    , tokenStart\n    , line\n    , lineStart;\n\n  exports.lex = lex;\n\n  function lex() {\n    skipWhiteSpace();\n\n    // Skip comments beginning with --\n    while (45 === input.charCodeAt(index) &&\n           45 === input.charCodeAt(index + 1)) {\n      scanComment();\n      skipWhiteSpace();\n    }\n    if (index >= length) return {\n        type : EOF\n      , value: '<eof>'\n      , line: line\n      , lineStart: lineStart\n      , range: [index, index]\n    };\n\n    var charCode = input.charCodeAt(index)\n      , next = input.charCodeAt(index + 1);\n\n    // Memorize the range index where the token begins.\n    tokenStart = index;\n    if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();\n\n    switch (charCode) {\n      case 39: case 34: // '\"\n        return scanStringLiteral();\n\n      case 48: case 49: case 50: case 51: case 52: case 53:\n      case 54: case 55: case 56: case 57: // 0-9\n        return scanNumericLiteral();\n\n      case 46: // .\n        // If the dot is followed by a digit it's a float.\n        if (isDecDigit(next)) return scanNumericLiteral();\n        if (46 === next) {\n          if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();\n          return scanPunctuator('..');\n        }\n        return scanPunctuator('.');\n\n      case 61: // =\n        if (61 === next) return scanPunctuator('==');\n        return scanPunctuator('=');\n\n      case 62: // >\n        if (features.bitwiseOperators)\n          if (62 === next) return scanPunctuator('>>');\n        if (61 === next) return scanPunctuator('>=');\n        return scanPunctuator('>');\n\n      case 60: // <\n        if (features.bitwiseOperators)\n          if (60 === next) return scanPunctuator('<<');\n        if (61 === next) return scanPunctuator('<=');\n        return scanPunctuator('<');\n\n      case 126: // ~\n        if (61 === next) return scanPunctuator('~=');\n        if (!features.bitwiseOperators)\n          break;\n        return scanPunctuator('~');\n\n      case 58: // :\n        if (features.labels)\n          if (58 === next) return scanPunctuator('::');\n        return scanPunctuator(':');\n\n      case 91: // [\n        // Check for a multiline string, they begin with [= or [[\n        if (91 === next || 61 === next) return scanLongStringLiteral();\n        return scanPunctuator('[');\n\n      case 47: // /\n        // Check for integer division op (//)\n        if (features.integerDivision)\n          if (47 === next) return scanPunctuator('//');\n        return scanPunctuator('/');\n\n      case 38: case 124: // & |\n        if (!features.bitwiseOperators)\n          break;\n\n        /* fall through */\n      case 42: case 94: case 37: case 44: case 123: case 125:\n      case 93: case 40: case 41: case 59: case 35: case 45:\n      case 43: // * ^ % , { } ] ( ) ; # - +\n        return scanPunctuator(input.charAt(index));\n    }\n\n    return unexpected(input.charAt(index));\n  }\n\n  // Whitespace has no semantic meaning in lua so simply skip ahead while\n  // tracking the encounted newlines. Any kind of eol sequence is counted as a\n  // single line.\n\n  function consumeEOL() {\n    var charCode = input.charCodeAt(index)\n      , peekCharCode = input.charCodeAt(index + 1);\n\n    if (isLineTerminator(charCode)) {\n      // Count \\n\\r and \\r\\n as one newline.\n      if (10 === charCode && 13 === peekCharCode) ++index;\n      if (13 === charCode && 10 === peekCharCode) ++index;\n      ++line;\n      lineStart = ++index;\n\n      return true;\n    }\n    return false;\n  }\n\n  function skipWhiteSpace() {\n    while (index < length) {\n      var charCode = input.charCodeAt(index);\n      if (isWhiteSpace(charCode)) {\n        ++index;\n      } else if (!consumeEOL()) {\n        break;\n      }\n    }\n  }\n\n  // Identifiers, keywords, booleans and nil all look the same syntax wise. We\n  // simply go through them one by one and defaulting to an identifier if no\n  // previous case matched.\n\n  function scanIdentifierOrKeyword() {\n    var value, type;\n\n    // Slicing the input string is prefered before string concatenation in a\n    // loop for performance reasons.\n    while (isIdentifierPart(input.charCodeAt(++index)));\n    value = encodingMode.fixup(input.slice(tokenStart, index));\n\n    // Decide on the token type and possibly cast the value.\n    if (isKeyword(value)) {\n      type = Keyword;\n    } else if ('true' === value || 'false' === value) {\n      type = BooleanLiteral;\n      value = ('true' === value);\n    } else if ('nil' === value) {\n      type = NilLiteral;\n      value = null;\n    } else {\n      type = Identifier;\n    }\n\n    return {\n        type: type\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Once a punctuator reaches this function it should already have been\n  // validated so we simply return it as a token.\n\n  function scanPunctuator(value) {\n    index += value.length;\n    return {\n        type: Punctuator\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // A vararg literal consists of three dots.\n\n  function scanVarargLiteral() {\n    index += 3;\n    return {\n        type: VarargLiteral\n      , value: '...'\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Find the string literal by matching the delimiter marks used.\n\n  function scanStringLiteral() {\n    var delimiter = input.charCodeAt(index++)\n      , beginLine = line\n      , beginLineStart = lineStart\n      , stringStart = index\n      , string = encodingMode.discardStrings ? null : ''\n      , charCode;\n\n    for (;;) {\n      charCode = input.charCodeAt(index++);\n      if (delimiter === charCode) break;\n      // EOF or `\\n` terminates a string literal. If we haven't found the\n      // ending delimiter by now, raise an exception.\n      if (index > length || isLineTerminator(charCode)) {\n        string += input.slice(stringStart, index - 1);\n        raise(null, errors.unfinishedString, input.slice(tokenStart, index - 1));\n      }\n      if (92 === charCode) { // backslash\n        if (!encodingMode.discardStrings) {\n          var beforeEscape = input.slice(stringStart, index - 1);\n          string += encodingMode.fixup(beforeEscape);\n        }\n        var escapeValue = readEscapeSequence();\n        if (!encodingMode.discardStrings)\n          string += escapeValue;\n        stringStart = index;\n      }\n    }\n    if (!encodingMode.discardStrings) {\n      string += encodingMode.encodeByte(null);\n      string += encodingMode.fixup(input.slice(stringStart, index - 1));\n    }\n\n    return {\n        type: StringLiteral\n      , value: string\n      , line: beginLine\n      , lineStart: beginLineStart\n      , lastLine: line\n      , lastLineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Expect a multiline string literal and return it as a regular string\n  // literal, if it doesn't validate into a valid multiline string, throw an\n  // exception.\n\n  function scanLongStringLiteral() {\n    var beginLine = line\n      , beginLineStart = lineStart\n      , string = readLongString(false);\n    // Fail if it's not a multiline literal.\n    if (false === string) raise(token, errors.expected, '[', tokenValue(token));\n\n    return {\n        type: StringLiteral\n      , value: encodingMode.discardStrings ? null : encodingMode.fixup(string)\n      , line: beginLine\n      , lineStart: beginLineStart\n      , lastLine: line\n      , lastLineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Numeric literals will be returned as floating-point numbers instead of\n  // strings. The raw value should be retrieved from slicing the input string\n  // later on in the process.\n  //\n  // If a hexadecimal number is encountered, it will be converted.\n\n  function scanNumericLiteral() {\n    var character = input.charAt(index)\n      , next = input.charAt(index + 1);\n\n    var literal = ('0' === character && 'xX'.indexOf(next || null) >= 0) ?\n      readHexLiteral() : readDecLiteral();\n\n    var foundImaginaryUnit = readImaginaryUnitSuffix()\n      , foundInt64Suffix = readInt64Suffix();\n\n    if (foundInt64Suffix && (foundImaginaryUnit || literal.hasFractionPart)) {\n      raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n    }\n\n    return {\n        type: NumericLiteral\n      , value: literal.value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  function readImaginaryUnitSuffix() {\n    if (!features.imaginaryNumbers) return;\n\n    // Imaginary unit number suffix is optional.\n    // See http://luajit.org/ext_ffi_api.html#literals\n    if ('iI'.indexOf(input.charAt(index) || null) >= 0) {\n      ++index;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function readInt64Suffix() {\n    if (!features.integerSuffixes) return;\n\n    // Int64/uint64 number suffix is optional.\n    // See http://luajit.org/ext_ffi_api.html#literals\n\n    if ('uU'.indexOf(input.charAt(index) || null) >= 0) {\n      ++index;\n      if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n          ++index;\n          return 'ULL';\n        } else {\n          // UL but no L\n          raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        }\n      } else {\n        // U but no L\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n      }\n    } else if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n          ++index;\n          return 'LL';\n        } else {\n          // First L but no second L\n          raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        }\n    }\n  }\n\n  // Lua hexadecimals have an optional fraction part and an optional binary\n  // exoponent part. These are not included in JavaScript so we will compute\n  // all three parts separately and then sum them up at the end of the function\n  // with the following algorithm.\n  //\n  //     Digit := toDec(digit)\n  //     Fraction := toDec(fraction) / 16 ^ fractionCount\n  //     BinaryExp := 2 ^ binaryExp\n  //     Number := ( Digit + Fraction ) * BinaryExp\n\n  function readHexLiteral() {\n    var fraction = 0 // defaults to 0 as it gets summed\n      , binaryExponent = 1 // defaults to 1 as it gets multiplied\n      , binarySign = 1 // positive\n      , digit, fractionStart, exponentStart, digitStart;\n\n    digitStart = index += 2; // Skip 0x part\n\n    // A minimum of one hex digit is required.\n    if (!isHexDigit(input.charCodeAt(index)))\n      raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n    while (isHexDigit(input.charCodeAt(index))) ++index;\n    // Convert the hexadecimal digit to base 10.\n    digit = parseInt(input.slice(digitStart, index), 16);\n\n    // Fraction part is optional.\n    var foundFraction = false;\n    if ('.' === input.charAt(index)) {\n      foundFraction = true;\n      fractionStart = ++index;\n\n      while (isHexDigit(input.charCodeAt(index))) ++index;\n      fraction = input.slice(fractionStart, index);\n\n      // Empty fraction parts should default to 0, others should be converted\n      // 0.x form so we can use summation at the end.\n      fraction = (fractionStart === index) ? 0\n        : parseInt(fraction, 16) / Math.pow(16, index - fractionStart);\n    }\n\n    // Binary exponents are optional\n    var foundBinaryExponent = false;\n    if ('pP'.indexOf(input.charAt(index) || null) >= 0) {\n      foundBinaryExponent = true;\n      ++index;\n\n      // Sign part is optional and defaults to 1 (positive).\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0)\n        binarySign = ('+' === input.charAt(index++)) ? 1 : -1;\n\n      exponentStart = index;\n\n      // The binary exponent sign requires a decimal digit.\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n      binaryExponent = input.slice(exponentStart, index);\n\n      // Calculate the binary exponent of the number.\n      binaryExponent = Math.pow(2, binaryExponent * binarySign);\n    }\n\n    return {\n      value: (digit + fraction) * binaryExponent,\n      hasFractionPart: foundFraction || foundBinaryExponent\n    };\n  }\n\n  // Decimal numbers are exactly the same in Lua and in JavaScript, because of\n  // this we check where the token ends and then parse it with native\n  // functions.\n\n  function readDecLiteral() {\n    while (isDecDigit(input.charCodeAt(index))) ++index;\n    // Fraction part is optional\n    var foundFraction = false;\n    if ('.' === input.charAt(index)) {\n      foundFraction = true;\n      ++index;\n      // Fraction part defaults to 0\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n    }\n\n    // Exponent part is optional.\n    var foundExponent = false;\n    if ('eE'.indexOf(input.charAt(index) || null) >= 0) {\n      foundExponent = true;\n      ++index;\n      // Sign part is optional.\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0) ++index;\n      // An exponent is required to contain at least one decimal digit.\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n    }\n\n    return {\n      value: parseFloat(input.slice(tokenStart, index)),\n      hasFractionPart: foundFraction || foundExponent\n    };\n  }\n\n  function readUnicodeEscapeSequence() {\n    var sequenceStart = index++;\n\n    if (input.charAt(index++) !== '{')\n      raise(null, errors.braceExpected, '{', '\\\\' + input.slice(sequenceStart, index));\n    if (!isHexDigit(input.charCodeAt(index)))\n      raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index));\n\n    while (input.charCodeAt(index) === 0x30) ++index;\n    var escStart = index;\n\n    while (isHexDigit(input.charCodeAt(index))) {\n      ++index;\n      if (index - escStart > 6)\n        raise(null, errors.tooLargeCodepoint, '\\\\' + input.slice(sequenceStart, index));\n    }\n\n    var b = input.charAt(index++);\n    if (b !== '}') {\n      if ((b === '\"') || (b === \"'\"))\n        raise(null, errors.braceExpected, '}', '\\\\' + input.slice(sequenceStart, index--));\n      else\n        raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index));\n    }\n\n    var codepoint = parseInt(input.slice(escStart, index - 1) || '0', 16);\n    var frag = '\\\\' + input.slice(sequenceStart, index);\n\n    if (codepoint > 0x10ffff) {\n      raise(null, errors.tooLargeCodepoint, frag);\n    }\n\n    return encodingMode.encodeUTF8(codepoint, frag);\n  }\n\n  // Translate escape sequences to the actual characters.\n  function readEscapeSequence() {\n    var sequenceStart = index;\n    switch (input.charAt(index)) {\n      // Lua allow the following escape sequences.\n      case 'a': ++index; return '\\x07';\n      case 'n': ++index; return '\\n';\n      case 'r': ++index; return '\\r';\n      case 't': ++index; return '\\t';\n      case 'v': ++index; return '\\x0b';\n      case 'b': ++index; return '\\b';\n      case 'f': ++index; return '\\f';\n\n      // Backslash at the end of the line. We treat all line endings as equivalent,\n      // and as representing the [LF] character (code 10). Lua 5.1 through 5.3\n      // have been verified to behave the same way.\n      case '\\r':\n      case '\\n':\n        consumeEOL();\n        return '\\n';\n\n      case '0': case '1': case '2': case '3': case '4':\n      case '5': case '6': case '7': case '8': case '9':\n        // \\ddd, where ddd is a sequence of up to three decimal digits.\n        while (isDecDigit(input.charCodeAt(index)) && index - sequenceStart < 3) ++index;\n\n        var frag = input.slice(sequenceStart, index);\n        var ddd = parseInt(frag, 10);\n        if (ddd > 255) {\n          raise(null, errors.decimalEscapeTooLarge, '\\\\' + ddd);\n        }\n        return encodingMode.encodeByte(ddd, '\\\\' + frag);\n\n      case 'z':\n        if (features.skipWhitespaceEscape) {\n          ++index;\n          skipWhiteSpace();\n          return '';\n        }\n        break;\n\n      case 'x':\n        if (features.hexEscapes) {\n          // \\xXX, where XX is a sequence of exactly two hexadecimal digits\n          if (isHexDigit(input.charCodeAt(index + 1)) &&\n              isHexDigit(input.charCodeAt(index + 2))) {\n            index += 3;\n            return encodingMode.encodeByte(parseInt(input.slice(sequenceStart + 1, index), 16), '\\\\' + input.slice(sequenceStart, index));\n          }\n          raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index + 2));\n        }\n        break;\n\n      case 'u':\n        if (features.unicodeEscapes)\n          return readUnicodeEscapeSequence();\n        break;\n\n      case '\\\\': case '\"': case \"'\":\n        return input.charAt(index++);\n    }\n\n    if (features.strictEscapes)\n      raise(null, errors.invalidEscape, '\\\\' + input.slice(sequenceStart, index + 1));\n    return input.charAt(index++);\n  }\n\n  // Comments begin with -- after which it will be decided if they are\n  // multiline comments or not.\n  //\n  // The multiline functionality works the exact same way as with string\n  // literals so we reuse the functionality.\n\n  function scanComment() {\n    tokenStart = index;\n    index += 2; // --\n\n    var character = input.charAt(index)\n      , content = ''\n      , isLong = false\n      , commentStart = index\n      , lineStartComment = lineStart\n      , lineComment = line;\n\n    if ('[' === character) {\n      content = readLongString(true);\n      // This wasn't a multiline comment after all.\n      if (false === content) content = character;\n      else isLong = true;\n    }\n    // Scan until next line as long as it's not a multiline comment.\n    if (!isLong) {\n      while (index < length) {\n        if (isLineTerminator(input.charCodeAt(index))) break;\n        ++index;\n      }\n      if (options.comments) content = input.slice(commentStart, index);\n    }\n\n    if (options.comments) {\n      var node = ast.comment(content, input.slice(tokenStart, index));\n\n      // `Marker`s depend on tokens available in the parser and as comments are\n      // intercepted in the lexer all location data is set manually.\n      if (options.locations) {\n        node.loc = {\n            start: { line: lineComment, column: tokenStart - lineStartComment }\n          , end: { line: line, column: index - lineStart }\n        };\n      }\n      if (options.ranges) {\n        node.range = [tokenStart, index];\n      }\n      if (options.onCreateNode) options.onCreateNode(node);\n      comments.push(node);\n    }\n  }\n\n  // Read a multiline string by calculating the depth of `=` characters and\n  // then appending until an equal depth is found.\n\n  function readLongString(isComment) {\n    var level = 0\n      , content = ''\n      , terminator = false\n      , character, stringStart, firstLine = line;\n\n    ++index; // [\n\n    // Calculate the depth of the comment.\n    while ('=' === input.charAt(index + level)) ++level;\n    // Exit, this is not a long string afterall.\n    if ('[' !== input.charAt(index + level)) return false;\n\n    index += level + 1;\n\n    // If the first character is a newline, ignore it and begin on next line.\n    if (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n\n    stringStart = index;\n    while (index < length) {\n      // To keep track of line numbers run the `consumeEOL()` which increments\n      // its counter.\n      while (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n\n      character = input.charAt(index++);\n\n      // Once the delimiter is found, iterate through the depth count and see\n      // if it matches.\n      if (']' === character) {\n        terminator = true;\n        for (var i = 0; i < level; ++i) {\n          if ('=' !== input.charAt(index + i)) terminator = false;\n        }\n        if (']' !== input.charAt(index + level)) terminator = false;\n      }\n\n      // We reached the end of the multiline string. Get out now.\n      if (terminator) {\n        content += input.slice(stringStart, index - 1);\n        index += level + 1;\n        return content;\n      }\n    }\n\n    raise(null, isComment ?\n                errors.unfinishedLongComment :\n                errors.unfinishedLongString,\n          firstLine, '<eof>');\n  }\n\n  // ## Lex functions and helpers.\n\n  // Read the next token.\n  //\n  // This is actually done by setting the current token to the lookahead and\n  // reading in the new lookahead token.\n\n  function next() {\n    previousToken = token;\n    token = lookahead;\n    lookahead = lex();\n  }\n\n  // Consume a token if its value matches. Once consumed or not, return the\n  // success of the operation.\n\n  function consume(value) {\n    if (value === token.value) {\n      next();\n      return true;\n    }\n    return false;\n  }\n\n  // Expect the next token value to match. If not, throw an exception.\n\n  function expect(value) {\n    if (value === token.value) next();\n    else raise(token, errors.expected, value, tokenValue(token));\n  }\n\n  // ### Validation functions\n\n  function isWhiteSpace(charCode) {\n    return 9 === charCode || 32 === charCode || 0xB === charCode || 0xC === charCode;\n  }\n\n  function isLineTerminator(charCode) {\n    return 10 === charCode || 13 === charCode;\n  }\n\n  function isDecDigit(charCode) {\n    return charCode >= 48 && charCode <= 57;\n  }\n\n  function isHexDigit(charCode) {\n    return (charCode >= 48 && charCode <= 57) || (charCode >= 97 && charCode <= 102) || (charCode >= 65 && charCode <= 70);\n  }\n\n  // From [Lua 5.2](http://www.lua.org/manual/5.2/manual.html#8.1) onwards\n  // identifiers cannot use 'locale-dependent' letters (i.e. dependent on the C locale).\n  // On the other hand, LuaJIT allows arbitrary octets  128 in identifiers.\n\n  function isIdentifierStart(charCode) {\n    if ((charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode)\n      return true;\n    if (features.extendedIdentifiers && charCode >= 128)\n      return true;\n    return false;\n  }\n\n  function isIdentifierPart(charCode) {\n    if ((charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode || (charCode >= 48 && charCode <= 57))\n      return true;\n    if (features.extendedIdentifiers && charCode >= 128)\n      return true;\n    return false;\n  }\n\n  // [3.1 Lexical Conventions](http://www.lua.org/manual/5.2/manual.html#3.1)\n  //\n  // `true`, `false` and `nil` will not be considered keywords, but literals.\n\n  function isKeyword(id) {\n    switch (id.length) {\n      case 2:\n        return 'do' === id || 'if' === id || 'in' === id || 'or' === id;\n      case 3:\n        return 'and' === id || 'end' === id || 'for' === id || 'not' === id;\n      case 4:\n        if ('else' === id || 'then' === id)\n          return true;\n        if (features.labels && !features.contextualGoto)\n          return ('goto' === id);\n        return false;\n      case 5:\n        return 'break' === id || 'local' === id || 'until' === id || 'while' === id;\n      case 6:\n        return 'elseif' === id || 'repeat' === id || 'return' === id;\n      case 8:\n        return 'function' === id;\n    }\n    return false;\n  }\n\n  function isUnary(token) {\n    if (Punctuator === token.type) return '#-~'.indexOf(token.value) >= 0;\n    if (Keyword === token.type) return 'not' === token.value;\n    return false;\n  }\n\n  // Check if the token syntactically closes a block.\n\n  function isBlockFollow(token) {\n    if (EOF === token.type) return true;\n    if (Keyword !== token.type) return false;\n    switch (token.value) {\n      case 'else': case 'elseif':\n      case 'end': case 'until':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // Scope\n  // -----\n\n  // Store each block scope as a an array of identifier names. Each scope is\n  // stored in an FILO-array.\n  var scopes\n    // The current scope index\n    , scopeDepth\n    // A list of all global identifier nodes.\n    , globals;\n\n  // Create a new scope inheriting all declarations from the previous scope.\n  function createScope() {\n    var scope = scopes[scopeDepth++].slice();\n    scopes.push(scope);\n    if (options.onCreateScope) options.onCreateScope();\n  }\n\n  // Exit and remove the current scope.\n  function destroyScope() {\n    var scope = scopes.pop();\n    --scopeDepth;\n    if (options.onDestroyScope) options.onDestroyScope();\n  }\n\n  // Add identifier name to the current scope if it doesnt already exist.\n  function scopeIdentifierName(name) {\n    if (options.onLocalDeclaration) options.onLocalDeclaration(name);\n    if (-1 !== indexOf(scopes[scopeDepth], name)) return;\n    scopes[scopeDepth].push(name);\n  }\n\n  // Add identifier to the current scope\n  function scopeIdentifier(node) {\n    scopeIdentifierName(node.name);\n    attachScope(node, true);\n  }\n\n  // Attach scope information to node. If the node is global, store it in the\n  // globals array so we can return the information to the user.\n  function attachScope(node, isLocal) {\n    if (!isLocal && -1 === indexOfObject(globals, 'name', node.name))\n      globals.push(node);\n\n    node.isLocal = isLocal;\n  }\n\n  // Is the identifier name available in this scope.\n  function scopeHasName(name) {\n    return (-1 !== indexOf(scopes[scopeDepth], name));\n  }\n\n  // Location tracking\n  // -----------------\n  //\n  // Locations are stored in FILO-array as a `Marker` object consisting of both\n  // `loc` and `range` data. Once a `Marker` is popped off the list an end\n  // location is added and the data is attached to a syntax node.\n\n  var locations = []\n    , trackLocations;\n\n  function createLocationMarker() {\n    return new Marker(token);\n  }\n\n  function Marker(token) {\n    if (options.locations) {\n      this.loc = {\n          start: {\n            line: token.line\n          , column: token.range[0] - token.lineStart\n        }\n        , end: {\n            line: 0\n          , column: 0\n        }\n      };\n    }\n    if (options.ranges) this.range = [token.range[0], 0];\n  }\n\n  // Complete the location data stored in the `Marker` by adding the location\n  // of the *previous token* as an end location.\n  Marker.prototype.complete = function() {\n    if (options.locations) {\n      this.loc.end.line = previousToken.lastLine || previousToken.line;\n      this.loc.end.column = previousToken.range[1] - (previousToken.lastLineStart || previousToken.lineStart);\n    }\n    if (options.ranges) {\n      this.range[1] = previousToken.range[1];\n    }\n  };\n\n  Marker.prototype.bless = function (node) {\n    if (this.loc) {\n      var loc = this.loc;\n      node.loc = {\n        start: {\n          line: loc.start.line,\n          column: loc.start.column\n        },\n        end: {\n          line: loc.end.line,\n          column: loc.end.column\n        }\n      };\n    }\n    if (this.range) {\n      node.range = [\n        this.range[0],\n        this.range[1]\n      ];\n    }\n  };\n\n  // Create a new `Marker` and add it to the FILO-array.\n  function markLocation() {\n    if (trackLocations) locations.push(createLocationMarker());\n  }\n\n  // Push an arbitrary `Marker` object onto the FILO-array.\n  function pushLocation(marker) {\n    if (trackLocations) locations.push(marker);\n  }\n\n  // Control flow tracking\n  // ---------------------\n  // A context object that validates loop breaks and `goto`-based control flow.\n\n  function FullFlowContext() {\n    this.scopes = [];\n    this.pendingGotos = [];\n  }\n\n  FullFlowContext.prototype.isInLoop = function () {\n    var i = this.scopes.length;\n    while (i --> 0) {\n      if (this.scopes[i].isLoop)\n        return true;\n    }\n    return false;\n  };\n\n  FullFlowContext.prototype.pushScope = function (isLoop) {\n    var scope = {\n      labels: {},\n      locals: [],\n      deferredGotos: [],\n      isLoop: !!isLoop\n    };\n    this.scopes.push(scope);\n  };\n\n  FullFlowContext.prototype.popScope = function () {\n    for (var i = 0; i < this.pendingGotos.length; ++i) {\n      var theGoto = this.pendingGotos[i];\n      if (theGoto.maxDepth >= this.scopes.length)\n        if (--theGoto.maxDepth <= 0)\n          raise(theGoto.token, errors.labelNotVisible, theGoto.target);\n    }\n\n    this.scopes.pop();\n  };\n\n  FullFlowContext.prototype.addGoto = function (target, token) {\n    var localCounts = [];\n\n    for (var i = 0; i < this.scopes.length; ++i) {\n      var scope = this.scopes[i];\n      localCounts.push(scope.locals.length);\n      if (Object.prototype.hasOwnProperty.call(scope.labels, target))\n        return;\n    }\n\n    this.pendingGotos.push({\n      maxDepth: this.scopes.length,\n      target: target,\n      token: token,\n      localCounts: localCounts\n    });\n  };\n\n  FullFlowContext.prototype.addLabel = function (name, token) {\n    var scope = this.currentScope();\n\n    if (Object.prototype.hasOwnProperty.call(scope.labels, name)) {\n      raise(token, errors.labelAlreadyDefined, name, scope.labels[name].line);\n    } else {\n      var newGotos = [];\n\n      for (var i = 0; i < this.pendingGotos.length; ++i) {\n        var theGoto = this.pendingGotos[i];\n\n        if (theGoto.maxDepth >= this.scopes.length && theGoto.target === name) {\n          if (theGoto.localCounts[this.scopes.length - 1] < scope.locals.length) {\n            scope.deferredGotos.push(theGoto);\n          }\n          continue;\n        }\n\n        newGotos.push(theGoto);\n      }\n\n      this.pendingGotos = newGotos;\n    }\n\n    scope.labels[name] = {\n      localCount: scope.locals.length,\n      line: token.line\n    };\n  };\n\n  FullFlowContext.prototype.addLocal = function (name, token) {\n    this.currentScope().locals.push({\n      name: name,\n      token: token\n    });\n  };\n\n  FullFlowContext.prototype.currentScope = function () {\n    return this.scopes[this.scopes.length - 1];\n  };\n\n  FullFlowContext.prototype.raiseDeferredErrors = function () {\n    var scope = this.currentScope();\n    var bads = scope.deferredGotos;\n    for (var i = 0; i < bads.length; ++i) {\n      var theGoto = bads[i];\n      raise(theGoto.token, errors.gotoJumpInLocalScope, theGoto.target, scope.locals[theGoto.localCounts[this.scopes.length - 1]].name);\n    }\n    // Would be dead code currently, but may be useful later\n    // if (bads.length)\n    //   scope.deferredGotos = [];\n  };\n\n  // Simplified context that only checks the validity of loop breaks.\n\n  function LoopFlowContext() {\n    this.level = 0;\n    this.loopLevels = [];\n  }\n\n  LoopFlowContext.prototype.isInLoop = function () {\n    return !!this.loopLevels.length;\n  };\n\n  LoopFlowContext.prototype.pushScope = function (isLoop) {\n    ++this.level;\n    if (isLoop)\n      this.loopLevels.push(this.level);\n  };\n\n  LoopFlowContext.prototype.popScope = function () {\n    var levels = this.loopLevels;\n    var levlen = levels.length;\n    if (levlen) {\n      if (levels[levlen - 1] === this.level)\n        levels.pop();\n    }\n    --this.level;\n  };\n\n  LoopFlowContext.prototype.addGoto =\n  LoopFlowContext.prototype.addLabel =\n  /* istanbul ignore next */\n  function () { throw new Error('This should never happen'); };\n\n  LoopFlowContext.prototype.addLocal =\n  LoopFlowContext.prototype.raiseDeferredErrors =\n  function () {};\n\n  function makeFlowContext() {\n    return features.labels ? new FullFlowContext() : new LoopFlowContext();\n  }\n\n  // Parse functions\n  // ---------------\n\n  // Chunk is the main program object. Syntactically it's the same as a block.\n  //\n  //     chunk ::= block\n\n  function parseChunk() {\n    next();\n    markLocation();\n    if (options.scope) createScope();\n    var flowContext = makeFlowContext();\n    flowContext.allowVararg = true;\n    flowContext.pushScope();\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    if (EOF !== token.type) unexpected(token);\n    // If the body is empty no previousToken exists when finishNode runs.\n    if (trackLocations && !body.length) previousToken = token;\n    return finishNode(ast.chunk(body));\n  }\n\n  // A block contains a list of statements with an optional return statement\n  // as its last statement.\n  //\n  //     block ::= {stat} [retstat]\n\n  function parseBlock(flowContext) {\n    var block = []\n      , statement;\n\n    while (!isBlockFollow(token)) {\n      // Return has to be the last statement in a block.\n      // Likewise 'break' in Lua older than 5.2\n      if ('return' === token.value || (!features.relaxedBreak && 'break' === token.value)) {\n        block.push(parseStatement(flowContext));\n        break;\n      }\n      statement = parseStatement(flowContext);\n      consume(';');\n      // Statements are only added if they are returned, this allows us to\n      // ignore some statements, such as EmptyStatement.\n      if (statement) block.push(statement);\n    }\n\n    // Doesn't really need an ast node\n    return block;\n  }\n\n  // There are two types of statements, simple and compound.\n  //\n  //     statement ::= break | goto | do | while | repeat | return\n  //          | if | for | function | local | label | assignment\n  //          | functioncall | ';'\n\n  function parseStatement(flowContext) {\n    markLocation();\n\n    if (Punctuator === token.type) {\n      if (consume('::')) return parseLabelStatement(flowContext);\n    }\n\n    // When a `;` is encounted, simply eat it without storing it.\n    if (features.emptyStatement) {\n      if (consume(';')) {\n        if (trackLocations) locations.pop();\n        return;\n      }\n    }\n\n    flowContext.raiseDeferredErrors();\n\n    if (Keyword === token.type) {\n      switch (token.value) {\n        case 'local':    next(); return parseLocalStatement(flowContext);\n        case 'if':       next(); return parseIfStatement(flowContext);\n        case 'return':   next(); return parseReturnStatement(flowContext);\n        case 'function': next();\n          var name = parseFunctionName();\n          return parseFunctionDeclaration(name);\n        case 'while':    next(); return parseWhileStatement(flowContext);\n        case 'for':      next(); return parseForStatement(flowContext);\n        case 'repeat':   next(); return parseRepeatStatement(flowContext);\n        case 'break':    next();\n          if (!flowContext.isInLoop())\n            raise(token, errors.noLoopToBreak, token.value);\n          return parseBreakStatement();\n        case 'do':       next(); return parseDoStatement(flowContext);\n        case 'goto':     next(); return parseGotoStatement(flowContext);\n      }\n    }\n\n    if (features.contextualGoto &&\n        token.type === Identifier && token.value === 'goto' &&\n        lookahead.type === Identifier && lookahead.value !== 'goto') {\n      next(); return parseGotoStatement(flowContext);\n    }\n\n    // Assignments memorizes the location and pushes it manually for wrapper nodes.\n    if (trackLocations) locations.pop();\n\n    return parseAssignmentOrCallStatement(flowContext);\n  }\n\n  // ## Statements\n\n  //     label ::= '::' Name '::'\n\n  function parseLabelStatement(flowContext) {\n    var nameToken = token\n      , label = parseIdentifier();\n\n    if (options.scope) {\n      scopeIdentifierName('::' + nameToken.value + '::');\n      attachScope(label, true);\n    }\n\n    expect('::');\n\n    flowContext.addLabel(nameToken.value, nameToken);\n    return finishNode(ast.labelStatement(label));\n  }\n\n  //     break ::= 'break'\n\n  function parseBreakStatement() {\n    return finishNode(ast.breakStatement());\n  }\n\n  //     goto ::= 'goto' Name\n\n  function parseGotoStatement(flowContext) {\n    var name = token.value\n      , gotoToken = previousToken\n      , label = parseIdentifier();\n\n    flowContext.addGoto(name, gotoToken);\n    return finishNode(ast.gotoStatement(label));\n  }\n\n  //     do ::= 'do' block 'end'\n\n  function parseDoStatement(flowContext) {\n    if (options.scope) createScope();\n    flowContext.pushScope();\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    expect('end');\n    return finishNode(ast.doStatement(body));\n  }\n\n  //     while ::= 'while' exp 'do' block 'end'\n\n  function parseWhileStatement(flowContext) {\n    var condition = parseExpectedExpression(flowContext);\n    expect('do');\n    if (options.scope) createScope();\n    flowContext.pushScope(true);\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    expect('end');\n    return finishNode(ast.whileStatement(condition, body));\n  }\n\n  //     repeat ::= 'repeat' block 'until' exp\n\n  function parseRepeatStatement(flowContext) {\n    if (options.scope) createScope();\n    flowContext.pushScope(true);\n    var body = parseBlock(flowContext);\n    expect('until');\n    flowContext.raiseDeferredErrors();\n    var condition = parseExpectedExpression(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    return finishNode(ast.repeatStatement(condition, body));\n  }\n\n  //     retstat ::= 'return' [exp {',' exp}] [';']\n\n  function parseReturnStatement(flowContext) {\n    var expressions = [];\n\n    if ('end' !== token.value) {\n      var expression = parseExpression(flowContext);\n      if (null != expression) expressions.push(expression);\n      while (consume(',')) {\n        expression = parseExpectedExpression(flowContext);\n        expressions.push(expression);\n      }\n      consume(';'); // grammar tells us ; is optional here.\n    }\n    return finishNode(ast.returnStatement(expressions));\n  }\n\n  //     if ::= 'if' exp 'then' block {elif} ['else' block] 'end'\n  //     elif ::= 'elseif' exp 'then' block\n\n  function parseIfStatement(flowContext) {\n    var clauses = []\n      , condition\n      , body\n      , marker;\n\n    // IfClauses begin at the same location as the parent IfStatement.\n    // It ends at the start of `end`, `else`, or `elseif`.\n    if (trackLocations) {\n      marker = locations[locations.length - 1];\n      locations.push(marker);\n    }\n    condition = parseExpectedExpression(flowContext);\n    expect('then');\n    if (options.scope) createScope();\n    flowContext.pushScope();\n    body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    clauses.push(finishNode(ast.ifClause(condition, body)));\n\n    if (trackLocations) marker = createLocationMarker();\n    while (consume('elseif')) {\n      pushLocation(marker);\n      condition = parseExpectedExpression(flowContext);\n      expect('then');\n      if (options.scope) createScope();\n      flowContext.pushScope();\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.elseifClause(condition, body)));\n      if (trackLocations) marker = createLocationMarker();\n    }\n\n    if (consume('else')) {\n      // Include the `else` in the location of ElseClause.\n      if (trackLocations) {\n        marker = new Marker(previousToken);\n        locations.push(marker);\n      }\n      if (options.scope) createScope();\n      flowContext.pushScope();\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.elseClause(body)));\n    }\n\n    expect('end');\n    return finishNode(ast.ifStatement(clauses));\n  }\n\n  // There are two types of for statements, generic and numeric.\n  //\n  //     for ::= Name '=' exp ',' exp [',' exp] 'do' block 'end'\n  //     for ::= namelist 'in' explist 'do' block 'end'\n  //     namelist ::= Name {',' Name}\n  //     explist ::= exp {',' exp}\n\n  function parseForStatement(flowContext) {\n    var variable = parseIdentifier()\n      , body;\n\n    // The start-identifier is local.\n\n    if (options.scope) {\n      createScope();\n      scopeIdentifier(variable);\n    }\n\n    // If the first expression is followed by a `=` punctuator, this is a\n    // Numeric For Statement.\n    if (consume('=')) {\n      // Start expression\n      var start = parseExpectedExpression(flowContext);\n      expect(',');\n      // End expression\n      var end = parseExpectedExpression(flowContext);\n      // Optional step expression\n      var step = consume(',') ? parseExpectedExpression(flowContext) : null;\n\n      expect('do');\n      flowContext.pushScope(true);\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      expect('end');\n      if (options.scope) destroyScope();\n\n      return finishNode(ast.forNumericStatement(variable, start, end, step, body));\n    }\n    // If not, it's a Generic For Statement\n    else {\n      // The namelist can contain one or more identifiers.\n      var variables = [variable];\n      while (consume(',')) {\n        variable = parseIdentifier();\n        // Each variable in the namelist is locally scoped.\n        if (options.scope) scopeIdentifier(variable);\n        variables.push(variable);\n      }\n      expect('in');\n      var iterators = [];\n\n      // One or more expressions in the explist.\n      do {\n        var expression = parseExpectedExpression(flowContext);\n        iterators.push(expression);\n      } while (consume(','));\n\n      expect('do');\n      flowContext.pushScope(true);\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      expect('end');\n      if (options.scope) destroyScope();\n\n      return finishNode(ast.forGenericStatement(variables, iterators, body));\n    }\n  }\n\n  // Local statements can either be variable assignments or function\n  // definitions. If a function definition is found, it will be delegated to\n  // `parseFunctionDeclaration()` with the isLocal flag.\n  //\n  // This AST structure might change into a local assignment with a function\n  // child.\n  //\n  //     local ::= 'local' 'function' Name funcdecl\n  //        | 'local' Name {',' Name} ['=' exp {',' exp}]\n\n  function parseLocalStatement(flowContext) {\n    var name\n      , declToken = previousToken;\n\n    if (Identifier === token.type) {\n      var variables = []\n        , init = [];\n\n      do {\n        name = parseIdentifier();\n\n        variables.push(name);\n        flowContext.addLocal(name.name, declToken);\n      } while (consume(','));\n\n      if (consume('=')) {\n        do {\n          var expression = parseExpectedExpression(flowContext);\n          init.push(expression);\n        } while (consume(','));\n      }\n\n      // Declarations doesn't exist before the statement has been evaluated.\n      // Therefore assignments can't use their declarator. And the identifiers\n      // shouldn't be added to the scope until the statement is complete.\n      if (options.scope) {\n        for (var i = 0, l = variables.length; i < l; ++i) {\n          scopeIdentifier(variables[i]);\n        }\n      }\n\n      return finishNode(ast.localStatement(variables, init));\n    }\n    if (consume('function')) {\n      name = parseIdentifier();\n      flowContext.addLocal(name.name, declToken);\n\n      if (options.scope) {\n        scopeIdentifier(name);\n        createScope();\n      }\n\n      // MemberExpressions are not allowed in local function statements.\n      return parseFunctionDeclaration(name, true);\n    } else {\n      raiseUnexpectedToken('<name>', token);\n    }\n  }\n\n  //     assignment ::= varlist '=' explist\n  //     var ::= Name | prefixexp '[' exp ']' | prefixexp '.' Name\n  //     varlist ::= var {',' var}\n  //     explist ::= exp {',' exp}\n  //\n  //     call ::= callexp\n  //     callexp ::= prefixexp args | prefixexp ':' Name args\n\n  function parseAssignmentOrCallStatement(flowContext) {\n    // Keep a reference to the previous token for better error messages in case\n    // of invalid statement\n    var previous = token\n      , marker, startMarker;\n    var lvalue, base, name;\n\n    var targets = [];\n\n    if (trackLocations) startMarker = createLocationMarker();\n\n    do {\n      if (trackLocations) marker = createLocationMarker();\n\n      if (Identifier === token.type) {\n        name = token.value;\n        base = parseIdentifier();\n        // Set the parent scope.\n        if (options.scope) attachScope(base, scopeHasName(name));\n        lvalue = true;\n      } else if ('(' === token.value) {\n        next();\n        base = parseExpectedExpression(flowContext);\n        expect(')');\n        lvalue = false;\n      } else {\n        return unexpected(token);\n      }\n\n      both: for (;;) {\n        var newBase;\n\n        switch (StringLiteral === token.type ? '\"' : token.value) {\n        case '.':\n        case '[':\n          lvalue = true;\n          break;\n        case ':':\n        case '(':\n        case '{':\n        case '\"':\n          lvalue = null;\n          break;\n        default:\n          break both;\n        }\n\n        base = parsePrefixExpressionPart(base, marker, flowContext);\n      }\n\n      targets.push(base);\n\n      if (',' !== token.value)\n        break;\n\n      if (!lvalue) {\n        return unexpected(token);\n      }\n\n      next();\n    } while (true);\n\n    if (targets.length === 1 && lvalue === null) {\n      pushLocation(marker);\n      return finishNode(ast.callStatement(targets[0]));\n    } else if (!lvalue) {\n      return unexpected(token);\n    }\n\n    expect('=');\n\n    var values = [];\n\n    do {\n      values.push(parseExpectedExpression(flowContext));\n    } while (consume(','));\n\n    pushLocation(startMarker);\n    return finishNode(ast.assignmentStatement(targets, values));\n  }\n\n  // ### Non-statements\n\n  //     Identifier ::= Name\n\n  function parseIdentifier() {\n    markLocation();\n    var identifier = token.value;\n    if (Identifier !== token.type) raiseUnexpectedToken('<name>', token);\n    next();\n    return finishNode(ast.identifier(identifier));\n  }\n\n  // Parse the functions parameters and body block. The name should already\n  // have been parsed and passed to this declaration function. By separating\n  // this we allow for anonymous functions in expressions.\n  //\n  // For local functions there's a boolean parameter which needs to be set\n  // when parsing the declaration.\n  //\n  //     funcdecl ::= '(' [parlist] ')' block 'end'\n  //     parlist ::= Name {',' Name} | [',' '...'] | '...'\n\n  function parseFunctionDeclaration(name, isLocal) {\n    var flowContext = makeFlowContext();\n    flowContext.pushScope();\n\n    var parameters = [];\n    expect('(');\n\n    // The declaration has arguments\n    if (!consume(')')) {\n      // Arguments are a comma separated list of identifiers, optionally ending\n      // with a vararg.\n      while (true) {\n        if (Identifier === token.type) {\n          var parameter = parseIdentifier();\n          // Function parameters are local.\n          if (options.scope) scopeIdentifier(parameter);\n\n          parameters.push(parameter);\n\n          if (consume(',')) continue;\n        }\n        // No arguments are allowed after a vararg.\n        else if (VarargLiteral === token.type) {\n          flowContext.allowVararg = true;\n          parameters.push(parsePrimaryExpression(flowContext));\n        } else {\n          raiseUnexpectedToken('<name> or \\'...\\'', token);\n        }\n        expect(')');\n        break;\n      }\n    }\n\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    expect('end');\n    if (options.scope) destroyScope();\n\n    isLocal = isLocal || false;\n    return finishNode(ast.functionStatement(name, parameters, isLocal, body));\n  }\n\n  // Parse the function name as identifiers and member expressions.\n  //\n  //     Name {'.' Name} [':' Name]\n\n  function parseFunctionName() {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n    base = parseIdentifier();\n\n    if (options.scope) {\n      attachScope(base, scopeHasName(base.name));\n      createScope();\n    }\n\n    while (consume('.')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      base = finishNode(ast.memberExpression(base, '.', name));\n    }\n\n    if (consume(':')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      base = finishNode(ast.memberExpression(base, ':', name));\n      if (options.scope) scopeIdentifierName('self');\n    }\n\n    return base;\n  }\n\n  //     tableconstructor ::= '{' [fieldlist] '}'\n  //     fieldlist ::= field {fieldsep field} fieldsep\n  //     field ::= '[' exp ']' '=' exp | Name = 'exp' | exp\n  //\n  //     fieldsep ::= ',' | ';'\n\n  function parseTableConstructor(flowContext) {\n    var fields = []\n      , key, value;\n\n    while (true) {\n      markLocation();\n      if (Punctuator === token.type && consume('[')) {\n        key = parseExpectedExpression(flowContext);\n        expect(']');\n        expect('=');\n        value = parseExpectedExpression(flowContext);\n        fields.push(finishNode(ast.tableKey(key, value)));\n      } else if (Identifier === token.type) {\n        if ('=' === lookahead.value) {\n          key = parseIdentifier();\n          next();\n          value = parseExpectedExpression(flowContext);\n          fields.push(finishNode(ast.tableKeyString(key, value)));\n        } else {\n          value = parseExpectedExpression(flowContext);\n          fields.push(finishNode(ast.tableValue(value)));\n        }\n      } else {\n        if (null == (value = parseExpression(flowContext))) {\n          locations.pop();\n          break;\n        }\n        fields.push(finishNode(ast.tableValue(value)));\n      }\n      if (',;'.indexOf(token.value) >= 0) {\n        next();\n        continue;\n      }\n      break;\n    }\n    expect('}');\n    return finishNode(ast.tableConstructorExpression(fields));\n  }\n\n  // Expression parser\n  // -----------------\n  //\n  // Expressions are evaluated and always return a value. If nothing is\n  // matched null will be returned.\n  //\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\n  //\n  //     primary ::= nil | false | true | Number | String | '...'\n  //          | functiondef | tableconstructor\n  //\n  //     prefixexp ::= (Name | '(' exp ')' ) { '[' exp ']'\n  //          | '.' Name | ':' Name args | args }\n  //\n\n  function parseExpression(flowContext) {\n    var expression = parseSubExpression(0, flowContext);\n    return expression;\n  }\n\n  // Parse an expression expecting it to be valid.\n\n  function parseExpectedExpression(flowContext) {\n    var expression = parseExpression(flowContext);\n    if (null == expression) raiseUnexpectedToken('<expression>', token);\n    else return expression;\n  }\n\n\n  // Return the precedence priority of the operator.\n  //\n  // As unary `-` can't be distinguished from binary `-`, unary precedence\n  // isn't described in this table but in `parseSubExpression()` itself.\n  //\n  // As this function gets hit on every expression it's been optimized due to\n  // the expensive CompareICStub which took ~8% of the parse time.\n\n  function binaryPrecedence(operator) {\n    var charCode = operator.charCodeAt(0)\n      , length = operator.length;\n\n    if (1 === length) {\n      switch (charCode) {\n        case 94: return 12; // ^\n        case 42: case 47: case 37: return 10; // * / %\n        case 43: case 45: return 9; // + -\n        case 38: return 6; // &\n        case 126: return 5; // ~\n        case 124: return 4; // |\n        case 60: case 62: return 3; // < >\n      }\n    } else if (2 === length) {\n      switch (charCode) {\n        case 47: return 10; // //\n        case 46: return 8; // ..\n        case 60: case 62:\n            if('<<' === operator || '>>' === operator) return 7; // << >>\n            return 3; // <= >=\n        case 61: case 126: return 3; // == ~=\n        case 111: return 1; // or\n      }\n    } else if (97 === charCode && 'and' === operator) return 2;\n    return 0;\n  }\n\n  // Implement an operator-precedence parser to handle binary operator\n  // precedence.\n  //\n  // We use this algorithm because it's compact, it's fast and Lua core uses\n  // the same so we can be sure our expressions are parsed in the same manner\n  // without excessive amounts of tests.\n  //\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\n\n  function parseSubExpression(minPrecedence, flowContext) {\n    var operator = token.value\n    // The left-hand side in binary operations.\n      , expression, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    // UnaryExpression\n    if (isUnary(token)) {\n      markLocation();\n      next();\n      var argument = parseSubExpression(10, flowContext);\n      if (argument == null) raiseUnexpectedToken('<expression>', token);\n      expression = finishNode(ast.unaryExpression(operator, argument));\n    }\n    if (null == expression) {\n      // PrimaryExpression\n      expression = parsePrimaryExpression(flowContext);\n\n      // PrefixExpression\n      if (null == expression) {\n        expression = parsePrefixExpression(flowContext);\n      }\n    }\n    // This is not a valid left hand expression.\n    if (null == expression) return null;\n\n    var precedence;\n    while (true) {\n      operator = token.value;\n\n      precedence = (Punctuator === token.type || Keyword === token.type) ?\n        binaryPrecedence(operator) : 0;\n\n      if (precedence === 0 || precedence <= minPrecedence) break;\n      // Right-hand precedence operators\n      if ('^' === operator || '..' === operator) --precedence;\n      next();\n      var right = parseSubExpression(precedence, flowContext);\n      if (null == right) raiseUnexpectedToken('<expression>', token);\n      // Push in the marker created before the loop to wrap its entirety.\n      if (trackLocations) locations.push(marker);\n      expression = finishNode(ast.binaryExpression(operator, expression, right));\n\n    }\n    return expression;\n  }\n\n  //     prefixexp ::= prefix {suffix}\n  //     prefix ::= Name | '(' exp ')'\n  //     suffix ::= '[' exp ']' | '.' Name | ':' Name args | args\n  //\n  //     args ::= '(' [explist] ')' | tableconstructor | String\n\n  function parsePrefixExpressionPart(base, marker, flowContext) {\n    var expression, identifier;\n\n    if (Punctuator === token.type) {\n      switch (token.value) {\n        case '[':\n          pushLocation(marker);\n          next();\n          expression = parseExpectedExpression(flowContext);\n          expect(']');\n          return finishNode(ast.indexExpression(base, expression));\n        case '.':\n          pushLocation(marker);\n          next();\n          identifier = parseIdentifier();\n          return finishNode(ast.memberExpression(base, '.', identifier));\n        case ':':\n          pushLocation(marker);\n          next();\n          identifier = parseIdentifier();\n          base = finishNode(ast.memberExpression(base, ':', identifier));\n          // Once a : is found, this has to be a CallExpression, otherwise\n          // throw an error.\n          pushLocation(marker);\n          return parseCallExpression(base, flowContext);\n        case '(': case '{': // args\n          pushLocation(marker);\n          return parseCallExpression(base, flowContext);\n      }\n    } else if (StringLiteral === token.type) {\n      pushLocation(marker);\n      return parseCallExpression(base, flowContext);\n    }\n\n    return null;\n  }\n\n  function parsePrefixExpression(flowContext) {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    // The prefix\n    if (Identifier === token.type) {\n      name = token.value;\n      base = parseIdentifier();\n      // Set the parent scope.\n      if (options.scope) attachScope(base, scopeHasName(name));\n    } else if (consume('(')) {\n      base = parseExpectedExpression(flowContext);\n      expect(')');\n    } else {\n      return null;\n    }\n\n    // The suffix\n    for (;;) {\n      var newBase = parsePrefixExpressionPart(base, marker, flowContext);\n      if (newBase === null)\n        break;\n      base = newBase;\n    }\n\n    return base;\n  }\n\n  //     args ::= '(' [explist] ')' | tableconstructor | String\n\n  function parseCallExpression(base, flowContext) {\n    if (Punctuator === token.type) {\n      switch (token.value) {\n        case '(':\n          if (!features.emptyStatement) {\n            if (token.line !== previousToken.line)\n              raise(null, errors.ambiguousSyntax, token.value);\n          }\n          next();\n\n          // List of expressions\n          var expressions = [];\n          var expression = parseExpression(flowContext);\n          if (null != expression) expressions.push(expression);\n          while (consume(',')) {\n            expression = parseExpectedExpression(flowContext);\n            expressions.push(expression);\n          }\n\n          expect(')');\n          return finishNode(ast.callExpression(base, expressions));\n\n        case '{':\n          markLocation();\n          next();\n          var table = parseTableConstructor(flowContext);\n          return finishNode(ast.tableCallExpression(base, table));\n      }\n    } else if (StringLiteral === token.type) {\n      return finishNode(ast.stringCallExpression(base, parsePrimaryExpression(flowContext)));\n    }\n\n    raiseUnexpectedToken('function arguments', token);\n  }\n\n  //     primary ::= String | Numeric | nil | true | false\n  //          | functiondef | tableconstructor | '...'\n\n  function parsePrimaryExpression(flowContext) {\n    var literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral\n      , value = token.value\n      , type = token.type\n      , marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    if (type === VarargLiteral && !flowContext.allowVararg) {\n      raise(token, errors.cannotUseVararg, token.value);\n    }\n\n    if (type & literals) {\n      pushLocation(marker);\n      var raw = input.slice(token.range[0], token.range[1]);\n      next();\n      return finishNode(ast.literal(type, value, raw));\n    } else if (Keyword === type && 'function' === value) {\n      pushLocation(marker);\n      next();\n      if (options.scope) createScope();\n      return parseFunctionDeclaration(null);\n    } else if (consume('{')) {\n      pushLocation(marker);\n      return parseTableConstructor(flowContext);\n    }\n  }\n\n  // Parser\n  // ------\n\n  // Export the main parser.\n  //\n  //   - `wait` Hold parsing until end() is called. Defaults to false\n  //   - `comments` Store comments. Defaults to true.\n  //   - `scope` Track identifier scope. Defaults to false.\n  //   - `locations` Store location information. Defaults to false.\n  //   - `ranges` Store the start and end character locations. Defaults to\n  //     false.\n  //   - `onCreateNode` Callback which will be invoked when a syntax node is\n  //     created.\n  //   - `onCreateScope` Callback which will be invoked when a new scope is\n  //     created.\n  //   - `onDestroyScope` Callback which will be invoked when the current scope\n  //     is destroyed.\n  //\n  // Example:\n  //\n  //     var parser = require('luaparser');\n  //     parser.parse('i = 0');\n\n  exports.parse = parse;\n\n  var versionFeatures = {\n    '5.1': {\n    },\n    '5.2': {\n      labels: true,\n      emptyStatement: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      relaxedBreak: true\n    },\n    '5.3': {\n      labels: true,\n      emptyStatement: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      unicodeEscapes: true,\n      bitwiseOperators: true,\n      integerDivision: true,\n      relaxedBreak: true\n    },\n    'LuaJIT': {\n      // XXX: LuaJIT language features may depend on compilation options; may need to\n      // rethink how to handle this. Specifically, there is a LUAJIT_ENABLE_LUA52COMPAT\n      // that removes contextual goto. Maybe add 'LuaJIT-5.2compat' as well?\n      labels: true,\n      contextualGoto: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      unicodeEscapes: true,\n      imaginaryNumbers: true,\n      integerSuffixes: true\n    }\n  };\n\n  function parse(_input, _options) {\n    if ('undefined' === typeof _options && 'object' === typeof _input) {\n      _options = _input;\n      _input = undefined;\n    }\n    if (!_options) _options = {};\n\n    input = _input || '';\n    options = assign({}, defaultOptions, _options);\n\n    // Rewind the lexer\n    index = 0;\n    line = 1;\n    lineStart = 0;\n    length = input.length;\n    // When tracking identifier scope, initialize with an empty scope.\n    scopes = [[]];\n    scopeDepth = 0;\n    globals = [];\n    locations = [];\n\n    if (!Object.prototype.hasOwnProperty.call(versionFeatures, options.luaVersion)) {\n      throw new Error(sprintf(\"Lua version '%1' not supported\", options.luaVersion));\n    }\n\n    features = assign({}, versionFeatures[options.luaVersion]);\n    if (options.extendedIdentifiers !== void 0)\n      features.extendedIdentifiers = !!options.extendedIdentifiers;\n\n    if (!Object.prototype.hasOwnProperty.call(encodingModes, options.encodingMode)) {\n      throw new Error(sprintf(\"Encoding mode '%1' not supported\", options.encodingMode));\n    }\n\n    encodingMode = encodingModes[options.encodingMode];\n\n    if (options.comments) comments = [];\n    if (!options.wait) return end();\n    return exports;\n  }\n\n  // Write to the source code buffer without beginning the parse.\n  exports.write = write;\n\n  function write(_input) {\n    input += String(_input);\n    length = input.length;\n    return exports;\n  }\n\n  // Send an EOF and begin parsing.\n  exports.end = end;\n\n  function end(_input) {\n    if ('undefined' !== typeof _input) write(_input);\n\n    // Ignore shebangs.\n    if (input && input.substr(0, 2) === '#!') input = input.replace(/^.*/, function (line) {\n      return line.replace(/./g, ' ');\n    });\n\n    length = input.length;\n    trackLocations = options.locations || options.ranges;\n    // Initialize with a lookahead token.\n    lookahead = lex();\n\n    var chunk = parseChunk();\n    if (options.comments) chunk.comments = comments;\n    if (options.scope) chunk.globals = globals;\n\n    /* istanbul ignore if */\n    if (locations.length > 0)\n      throw new Error('Location tracking failed. This is most likely a bug in luaparse');\n\n    return chunk;\n  }\n\n}));\n/* vim: set sw=2 ts=2 et tw=79 : */\n","/*! https://mths.be/luamin v1.0.4 by @mathias */\n;(function(root) {\n\n\t// Detect free variables `exports`\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar luaparse = root.luaparse || require('luaparse');\n\tluaparse.defaultOptions.comments = false;\n\tluaparse.defaultOptions.scope = true;\n\tvar parse = luaparse.parse;\n\n\tvar regexAlphaUnderscore = /[a-zA-Z_]/;\n\tvar regexAlphaNumUnderscore = /[a-zA-Z0-9_]/;\n\tvar regexDigits = /[0-9]/;\n\n\t// http://www.lua.org/manual/5.2/manual.html#3.4.7\n\t// http://www.lua.org/source/5.2/lparser.c.html#priority\n\tvar PRECEDENCE = {\n\t\t'or': 1,\n\t\t'and': 2,\n\t\t'<': 3, '>': 3, '<=': 3, '>=': 3, '~=': 3, '==': 3,\n\t\t'..': 5,\n\t\t'+': 6, '-': 6, // binary -\n\t\t'*': 7, '/': 7, '%': 7,\n\t\t'unarynot': 8, 'unary#': 8, 'unary-': 8, // unary -\n\t\t'^': 10\n\t};\n\n\tvar IDENTIFIER_PARTS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a',\n\t\t'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',\n\t\t'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E',\n\t\t'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n\t\t'U', 'V', 'W', 'X', 'Y', 'Z', '_'];\n\tvar IDENTIFIER_PARTS_MAX = IDENTIFIER_PARTS.length - 1;\n\n\tvar each = function(array, fn) {\n\t\tvar index = -1;\n\t\tvar length = array.length;\n\t\tvar max = length - 1;\n\t\twhile (++index < length) {\n\t\t\tfn(array[index], index < max);\n\t\t}\n\t};\n\n\tvar indexOf = function(array, value) {\n\t\tvar index = -1;\n\t\tvar length = array.length;\n\t\twhile (++index < length) {\n\t\t\tif (array[index] == value) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t}\n\t};\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tvar extend = function(destination, source) {\n\t\tvar key;\n\t\tif (source) {\n\t\t\tfor (key in source) {\n\t\t\t\tif (hasOwnProperty.call(source, key)) {\n\t\t\t\t\tdestination[key] = source[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn destination;\n\t};\n\n\tvar generateZeroes = function(length) {\n\t\tvar zero = '0';\n\t\tvar result = '';\n\t\tif (length < 1) {\n\t\t\treturn result;\n\t\t}\n\t\tif (length == 1) {\n\t\t\treturn zero;\n\t\t}\n\t\twhile (length) {\n\t\t\tif (length & 1) {\n\t\t\t\tresult += zero;\n\t\t\t}\n\t\t\tif (length >>= 1) {\n\t\t\t\tzero += zero;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\n\t// http://www.lua.org/manual/5.2/manual.html#3.1\n\tfunction isKeyword(id) {\n\t\tswitch (id.length) {\n\t\t\tcase 2:\n\t\t\t\treturn 'do' == id || 'if' == id || 'in' == id || 'or' == id;\n\t\t\tcase 3:\n\t\t\t\treturn 'and' == id || 'end' == id || 'for' == id || 'nil' == id ||\n\t\t\t\t\t'not' == id;\n\t\t\tcase 4:\n\t\t\t\treturn 'else' == id || 'goto' == id || 'then' == id || 'true' == id;\n\t\t\tcase 5:\n\t\t\t\treturn 'break' == id || 'false' == id || 'local' == id ||\n\t\t\t\t\t'until' == id || 'while' == id;\n\t\t\tcase 6:\n\t\t\t\treturn 'elseif' == id || 'repeat' == id || 'return' == id;\n\t\t\tcase 8:\n\t\t\t\treturn 'function' == id;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvar currentIdentifier;\n\tvar identifierMap;\n\tvar identifiersInUse;\n\tvar generateIdentifier = function(originalName) {\n\t\t// Preserve `self` in methods\n\t\tif (originalName == 'self') {\n\t\t\treturn originalName;\n\t\t}\n\n\t\tif (hasOwnProperty.call(identifierMap, originalName)) {\n\t\t\treturn identifierMap[originalName];\n\t\t}\n\t\tvar length = currentIdentifier.length;\n\t\tvar position = length - 1;\n\t\tvar character;\n\t\tvar index;\n\t\twhile (position >= 0) {\n\t\t\tcharacter = currentIdentifier.charAt(position);\n\t\t\tindex = indexOf(IDENTIFIER_PARTS, character);\n\t\t\tif (index != IDENTIFIER_PARTS_MAX) {\n\t\t\t\tcurrentIdentifier = currentIdentifier.substring(0, position) +\n\t\t\t\t\tIDENTIFIER_PARTS[index + 1] + generateZeroes(length - (position + 1));\n\t\t\t\tif (\n\t\t\t\t\tisKeyword(currentIdentifier) ||\n\t\t\t\t\tindexOf(identifiersInUse, currentIdentifier) > -1\n\t\t\t\t) {\n\t\t\t\t\treturn generateIdentifier(originalName);\n\t\t\t\t}\n\t\t\t\tidentifierMap[originalName] = currentIdentifier;\n\t\t\t\treturn currentIdentifier;\n\t\t\t}\n\t\t\t--position;\n\t\t}\n\t\tcurrentIdentifier = 'a' + generateZeroes(length);\n\t\tif (indexOf(identifiersInUse, currentIdentifier) > -1) {\n\t\t\treturn generateIdentifier(originalName);\n\t\t}\n\t\tidentifierMap[originalName] = currentIdentifier;\n\t\treturn currentIdentifier;\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar joinStatements = function(a, b, separator) {\n\t\tseparator || (separator = ' ');\n\n\t\tvar lastCharA = a.slice(-1);\n\t\tvar firstCharB = b.charAt(0);\n\n\t\tif (lastCharA == '' || firstCharB == '') {\n\t\t\treturn a + b;\n\t\t}\n\t\tif (regexAlphaUnderscore.test(lastCharA)) {\n\t\t\tif (regexAlphaNumUnderscore.test(firstCharB)) {\n\t\t\t\t// e.g. `while` + `1`\n\t\t\t\t// e.g. `local a` + `local b`\n\t\t\t\treturn a + separator + b;\n\t\t\t} else {\n\t\t\t\t// e.g. `not` + `(2>3 or 3<2)`\n\t\t\t\t// e.g. `x` + `^`\n\t\t\t\treturn a + b;\n\t\t\t}\n\t\t}\n\t\tif (regexDigits.test(lastCharA)) {\n\t\t\tif (\n\t\t\t\tfirstCharB == '(' ||\n\t\t\t\t!(firstCharB == '.' ||\n\t\t\t\tregexAlphaUnderscore.test(firstCharB))\n\t\t\t) {\n\t\t\t\t// e.g. `1` + `+`\n\t\t\t\t// e.g. `1` + `==`\n\t\t\t\treturn a + b;\n\t\t\t} else {\n\t\t\t\t// e.g. `1` + `..`\n\t\t\t\t// e.g. `1` + `and`\n\t\t\t\treturn a + separator + b;\n\t\t\t}\n\t\t}\n\t\tif (lastCharA == firstCharB && lastCharA == '-') {\n\t\t\t// e.g. `1-` + `-2`\n\t\t\treturn a + separator + b;\n\t\t}\n\t\treturn a + b;\n\t};\n\n\tvar formatBase = function(base) {\n\t\tvar result = '';\n\t\tvar type = base.type;\n\t\tvar needsParens = base.inParens && (\n\t\t\ttype == 'BinaryExpression' ||\n\t\t\ttype == 'FunctionDeclaration' ||\n\t\t\ttype == 'TableConstructorExpression' ||\n\t\t\ttype == 'LogicalExpression' ||\n\t\t\ttype == 'StringLiteral'\n\t\t);\n\t\tif (needsParens) {\n\t\t\tresult += '(';\n\t\t}\n\t\tresult += formatExpression(base);\n\t\tif (needsParens) {\n\t\t\tresult += ')';\n\t\t}\n\t\treturn result;\n\t};\n\n\tvar formatExpression = function(expression, options) {\n\n\t\toptions = extend({\n\t\t\t'precedence': 0,\n\t\t\t'preserveIdentifiers': false\n\t\t}, options);\n\n\t\tvar result = '';\n\t\tvar currentPrecedence;\n\t\tvar associativity;\n\t\tvar operator;\n\n\t\tvar expressionType = expression.type;\n\n\t\tif (expressionType == 'Identifier') {\n\n\t\t\tresult = expression.isLocal && !options.preserveIdentifiers\n\t\t\t\t? generateIdentifier(expression.name)\n\t\t\t\t: expression.name;\n\n\t\t} else if (\n\t\t\texpressionType == 'StringLiteral' ||\n\t\t\texpressionType == 'NumericLiteral' ||\n\t\t\texpressionType == 'BooleanLiteral' ||\n\t\t\texpressionType == 'NilLiteral' ||\n\t\t\texpressionType == 'VarargLiteral'\n\t\t) {\n\n\t\t\tresult = expression.raw;\n\n\t\t} else if (\n\t\t\texpressionType == 'LogicalExpression' ||\n\t\t\texpressionType == 'BinaryExpression'\n\t\t) {\n\n\t\t\t// If an expression with precedence x\n\t\t\t// contains an expression with precedence < x,\n\t\t\t// the inner expression must be wrapped in parens.\n\t\t\toperator = expression.operator;\n\t\t\tcurrentPrecedence = PRECEDENCE[operator];\n\t\t\tassociativity = 'left';\n\n\t\t\tresult = formatExpression(expression.left, {\n\t\t\t\t'precedence': currentPrecedence,\n\t\t\t\t'direction': 'left',\n\t\t\t\t'parent': operator\n\t\t\t});\n\t\t\tresult = joinStatements(result, operator);\n\t\t\tresult = joinStatements(result, formatExpression(expression.right, {\n\t\t\t\t'precedence': currentPrecedence,\n\t\t\t\t'direction': 'right',\n\t\t\t\t'parent': operator\n\t\t\t}));\n\n\t\t\tif (operator == '^' || operator == '..') {\n\t\t\t\tassociativity = \"right\";\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tcurrentPrecedence < options.precedence ||\n\t\t\t\t(\n\t\t\t\t\tcurrentPrecedence == options.precedence &&\n\t\t\t\t\tassociativity != options.direction &&\n\t\t\t\t\toptions.parent != '+' &&\n\t\t\t\t\t!(options.parent == '*' && (operator == '/' || operator == '*'))\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// The most simple case here is that of\n\t\t\t\t// protecting the parentheses on the RHS of\n\t\t\t\t// `1 - (2 - 3)` but deleting them from `(1 - 2) - 3`.\n\t\t\t\t// This is generally the right thing to do. The\n\t\t\t\t// semantics of `+` are special however: `1 + (2 - 3)`\n\t\t\t\t// == `1 + 2 - 3`. `-` and `+` are the only two operators\n\t\t\t\t// who share their precedence level. `*` also can\n\t\t\t\t// commute in such a way with `/`, but not with `%`\n\t\t\t\t// (all three share a precedence). So we test for\n\t\t\t\t// all of these conditions and avoid emitting\n\t\t\t\t// parentheses in the cases where we dont have to.\n\t\t\t\tresult = '(' + result + ')';\n\t\t\t}\n\n\t\t} else if (expressionType == 'UnaryExpression') {\n\n\t\t\toperator = expression.operator;\n\t\t\tcurrentPrecedence = PRECEDENCE['unary' + operator];\n\n\t\t\tresult = joinStatements(\n\t\t\t\toperator,\n\t\t\t\tformatExpression(expression.argument, {\n\t\t\t\t\t'precedence': currentPrecedence\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tif (\n\t\t\t\tcurrentPrecedence < options.precedence &&\n\t\t\t\t// In principle, we should parenthesize the RHS of an\n\t\t\t\t// expression like `3^-2`, because `^` has higher precedence\n\t\t\t\t// than unary `-` according to the manual. But that is\n\t\t\t\t// misleading on the RHS of `^`, since the parser will\n\t\t\t\t// always try to find a unary operator regardless of\n\t\t\t\t// precedence.\n\t\t\t\t!(\n\t\t\t\t\t(options.parent == '^') &&\n\t\t\t\t\toptions.direction == 'right'\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tresult = '(' + result + ')';\n\t\t\t}\n\n\t\t} else if (expressionType == 'CallExpression') {\n\n\t\t\tresult = formatBase(expression.base) + '(';\n\n\t\t\teach(expression.arguments, function(argument, needsComma) {\n\t\t\t\tresult += formatExpression(argument);\n\t\t\t\tif (needsComma) {\n\t\t\t\t\tresult += ',';\n\t\t\t\t}\n\t\t\t});\n\t\t\tresult += ')';\n\n\t\t} else if (expressionType == 'TableCallExpression') {\n\n\t\t\tresult = formatExpression(expression.base) +\n\t\t\t\tformatExpression(expression.arguments);\n\n\t\t} else if (expressionType == 'StringCallExpression') {\n\n\t\t\tresult = formatExpression(expression.base) +\n\t\t\t\tformatExpression(expression.argument);\n\n\t\t} else if (expressionType == 'IndexExpression') {\n\n\t\t\tresult = formatBase(expression.base) + '[' +\n\t\t\t\tformatExpression(expression.index) + ']';\n\n\t\t} else if (expressionType == 'MemberExpression') {\n\n\t\t\tresult = formatBase(expression.base) + expression.indexer +\n\t\t\t\tformatExpression(expression.identifier, {\n\t\t\t\t\t'preserveIdentifiers': true\n\t\t\t\t});\n\n\t\t} else if (expressionType == 'FunctionDeclaration') {\n\n\t\t\tresult = 'function(';\n\t\t\tif (expression.parameters.length) {\n\t\t\t\teach(expression.parameters, function(parameter, needsComma) {\n\t\t\t\t\t// `Identifier`s have a `name`, `VarargLiteral`s have a `value`\n\t\t\t\t\tresult += parameter.name\n\t\t\t\t\t\t? generateIdentifier(parameter.name)\n\t\t\t\t\t\t: parameter.value;\n\t\t\t\t\tif (needsComma) {\n\t\t\t\t\t\tresult += ',';\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tresult += ')';\n\t\t\tresult = joinStatements(result, formatStatementList(expression.body));\n\t\t\tresult = joinStatements(result, 'end');\n\n\t\t} else if (expressionType == 'TableConstructorExpression') {\n\n\t\t\tresult = '{';\n\n\t\t\teach(expression.fields, function(field, needsComma) {\n\t\t\t\tif (field.type == 'TableKey') {\n\t\t\t\t\tresult += '[' + formatExpression(field.key) + ']=' +\n\t\t\t\t\t\tformatExpression(field.value);\n\t\t\t\t} else if (field.type == 'TableValue') {\n\t\t\t\t\tresult += formatExpression(field.value);\n\t\t\t\t} else { // at this point, `field.type == 'TableKeyString'`\n\t\t\t\t\tresult += formatExpression(field.key, {\n\t\t\t\t\t\t// TODO: keep track of nested scopes (#18)\n\t\t\t\t\t\t'preserveIdentifiers': true\n\t\t\t\t\t}) + '=' + formatExpression(field.value);\n\t\t\t\t}\n\t\t\t\tif (needsComma) {\n\t\t\t\t\tresult += ',';\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tresult += '}';\n\n\t\t} else {\n\n\t\t\tthrow TypeError('Unknown expression type: `' + expressionType + '`');\n\n\t\t}\n\n\t\treturn result;\n\t};\n\n\tvar formatStatementList = function(body) {\n\t\tvar result = '';\n\t\teach(body, function(statement) {\n\t\t\tresult = joinStatements(result, formatStatement(statement), ';');\n\t\t});\n\t\treturn result;\n\t};\n\n\tvar formatStatement = function(statement) {\n\t\tvar result = '';\n\t\tvar statementType = statement.type;\n\n\t\tif (statementType == 'AssignmentStatement') {\n\n\t\t\t// left-hand side\n\t\t\teach(statement.variables, function(variable, needsComma) {\n\t\t\t\tresult += formatExpression(variable);\n\t\t\t\tif (needsComma) {\n\t\t\t\t\tresult += ',';\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// right-hand side\n\t\t\tresult += '=';\n\t\t\teach(statement.init, function(init, needsComma) {\n\t\t\t\tresult += formatExpression(init);\n\t\t\t\tif (needsComma) {\n\t\t\t\t\tresult += ',';\n\t\t\t\t}\n\t\t\t});\n\n\t\t} else if (statementType == 'LocalStatement') {\n\n\t\t\tresult = 'local ';\n\n\t\t\t// left-hand side\n\t\t\teach(statement.variables, function(variable, needsComma) {\n\t\t\t\t// Variables in a `LocalStatement` are always local, duh\n\t\t\t\tresult += generateIdentifier(variable.name);\n\t\t\t\tif (needsComma) {\n\t\t\t\t\tresult += ',';\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// right-hand side\n\t\t\tif (statement.init.length) {\n\t\t\t\tresult += '=';\n\t\t\t\teach(statement.init, function(init, needsComma) {\n\t\t\t\t\tresult += formatExpression(init);\n\t\t\t\t\tif (needsComma) {\n\t\t\t\t\t\tresult += ',';\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t} else if (statementType == 'CallStatement') {\n\n\t\t\tresult = formatExpression(statement.expression);\n\n\t\t} else if (statementType == 'IfStatement') {\n\n\t\t\tresult = joinStatements(\n\t\t\t\t'if',\n\t\t\t\tformatExpression(statement.clauses[0].condition)\n\t\t\t);\n\t\t\tresult = joinStatements(result, 'then');\n\t\t\tresult = joinStatements(\n\t\t\t\tresult,\n\t\t\t\tformatStatementList(statement.clauses[0].body)\n\t\t\t);\n\t\t\teach(statement.clauses.slice(1), function(clause) {\n\t\t\t\tif (clause.condition) {\n\t\t\t\t\tresult = joinStatements(result, 'elseif');\n\t\t\t\t\tresult = joinStatements(result, formatExpression(clause.condition));\n\t\t\t\t\tresult = joinStatements(result, 'then');\n\t\t\t\t} else {\n\t\t\t\t\tresult = joinStatements(result, 'else');\n\t\t\t\t}\n\t\t\t\tresult = joinStatements(result, formatStatementList(clause.body));\n\t\t\t});\n\t\t\tresult = joinStatements(result, 'end');\n\n\t\t} else if (statementType == 'WhileStatement') {\n\n\t\t\tresult = joinStatements('while', formatExpression(statement.condition));\n\t\t\tresult = joinStatements(result, 'do');\n\t\t\tresult = joinStatements(result, formatStatementList(statement.body));\n\t\t\tresult = joinStatements(result, 'end');\n\n\t\t} else if (statementType == 'DoStatement') {\n\n\t\t\tresult = joinStatements('do', formatStatementList(statement.body));\n\t\t\tresult = joinStatements(result, 'end');\n\n\t\t} else if (statementType == 'ReturnStatement') {\n\n\t\t\tresult = 'return';\n\n\t\t\teach(statement.arguments, function(argument, needsComma) {\n\t\t\t\tresult = joinStatements(result, formatExpression(argument));\n\t\t\t\tif (needsComma) {\n\t\t\t\t\tresult += ',';\n\t\t\t\t}\n\t\t\t});\n\n\t\t} else if (statementType == 'BreakStatement') {\n\n\t\t\tresult = 'break';\n\n\t\t} else if (statementType == 'RepeatStatement') {\n\n\t\t\tresult = joinStatements('repeat', formatStatementList(statement.body));\n\t\t\tresult = joinStatements(result, 'until');\n\t\t\tresult = joinStatements(result, formatExpression(statement.condition))\n\n\t\t} else if (statementType == 'FunctionDeclaration') {\n\n\t\t\tresult = (statement.isLocal ? 'local ' : '') + 'function ';\n\t\t\tresult += formatExpression(statement.identifier);\n\t\t\tresult += '(';\n\n\t\t\tif (statement.parameters.length) {\n\t\t\t\teach(statement.parameters, function(parameter, needsComma) {\n\t\t\t\t\t// `Identifier`s have a `name`, `VarargLiteral`s have a `value`\n\t\t\t\t\tresult += parameter.name\n\t\t\t\t\t\t? generateIdentifier(parameter.name)\n\t\t\t\t\t\t: parameter.value;\n\t\t\t\t\tif (needsComma) {\n\t\t\t\t\t\tresult += ',';\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tresult += ')';\n\t\t\tresult = joinStatements(result, formatStatementList(statement.body));\n\t\t\tresult = joinStatements(result, 'end');\n\n\t\t} else if (statementType == 'ForGenericStatement') {\n\t\t\t// see also `ForNumericStatement`\n\n\t\t\tresult = 'for ';\n\n\t\t\teach(statement.variables, function(variable, needsComma) {\n\t\t\t\t// The variables in a `ForGenericStatement` are always local\n\t\t\t\tresult += generateIdentifier(variable.name);\n\t\t\t\tif (needsComma) {\n\t\t\t\t\tresult += ',';\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tresult += ' in';\n\n\t\t\teach(statement.iterators, function(iterator, needsComma) {\n\t\t\t\tresult = joinStatements(result, formatExpression(iterator));\n\t\t\t\tif (needsComma) {\n\t\t\t\t\tresult += ',';\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tresult = joinStatements(result, 'do');\n\t\t\tresult = joinStatements(result, formatStatementList(statement.body));\n\t\t\tresult = joinStatements(result, 'end');\n\n\t\t} else if (statementType == 'ForNumericStatement') {\n\n\t\t\t// The variables in a `ForNumericStatement` are always local\n\t\t\tresult = 'for ' + generateIdentifier(statement.variable.name) + '=';\n\t\t\tresult += formatExpression(statement.start) + ',' +\n\t\t\t\tformatExpression(statement.end);\n\n\t\t\tif (statement.step) {\n\t\t\t\tresult += ',' + formatExpression(statement.step);\n\t\t\t}\n\n\t\t\tresult = joinStatements(result, 'do');\n\t\t\tresult = joinStatements(result, formatStatementList(statement.body));\n\t\t\tresult = joinStatements(result, 'end');\n\n\t\t} else if (statementType == 'LabelStatement') {\n\n\t\t\t// The identifier names in a `LabelStatement` can safely be renamed\n\t\t\tresult = '::' + generateIdentifier(statement.label.name) + '::';\n\n\t\t} else if (statementType == 'GotoStatement') {\n\n\t\t\t// The identifier names in a `GotoStatement` can safely be renamed\n\t\t\tresult = 'goto ' + generateIdentifier(statement.label.name);\n\n\t\t} else {\n\n\t\t\tthrow TypeError('Unknown statement type: `' + statementType + '`');\n\n\t\t}\n\n\t\treturn result;\n\t};\n\n\tvar minify = function(argument) {\n\t\t// `argument` can be a Lua code snippet (string)\n\t\t// or a luaparse-compatible AST (object)\n\t\tvar ast = typeof argument == 'string'\n\t\t\t? parse(argument)\n\t\t\t: argument;\n\n\t\t// (Re)set temporary identifier values\n\t\tidentifierMap = {};\n\t\tidentifiersInUse = [];\n\t\t// This is a shortcut to help generate the first identifier (`a`) faster\n\t\tcurrentIdentifier = '9';\n\n\t\t// Make sure global variable names aren't renamed\n\t\tif (ast.globals) {\n\t\t\teach(ast.globals, function(object) {\n\t\t\t\tvar name = object.name;\n\t\t\t\tidentifierMap[name] = name;\n\t\t\t\tidentifiersInUse.push(name);\n\t\t\t});\n\t\t} else {\n\t\t\tthrow Error('Missing required AST property: `globals`');\n\t\t}\n\n\t\treturn formatStatementList(ast.body);\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar luamin = {\n\t\t'version': '1.0.4',\n\t\t'minify': minify\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine(function() {\n\t\t\treturn luamin;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = luamin;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\textend(freeExports, luamin);\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.luamin = luamin;\n\t}\n\n}(this));\n","/* global exports:true, module:true, require:true, define:true, global:true */\n\n(function (root, name, factory) {\n  /* jshint eqeqeq:false */\n  'use strict';\n\n  // Used to determine if values are of the language type `Object`\n  var objectTypes = {\n        'function': true\n      , 'object': true\n    }\n    // Detect free variable `exports`\n    , freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports\n    // Detect free variable `module`\n    , freeModule = objectTypes[typeof module] && module && !module.nodeType && module\n    // Detect free variable `global`, from Node.js or Browserified code, and\n    // use it as `window`\n    , freeGlobal = freeExports && freeModule && typeof global == 'object' && global\n    // Detect the popular CommonJS extension `module.exports`\n    , moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  // Some AMD build optimizers, like r.js, check for specific condition\n  // patterns like the following:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // defined as an anonymous module.\n    define(['exports'], factory);\n    // In case the source has been processed and wrapped in a define module use\n    // the supplied `exports` object.\n    if (freeExports && moduleExports) factory(freeModule.exports);\n  }\n  // check for `exports` after `define` in case a build optimizer adds an\n  // `exports` object\n  else if (freeExports && freeModule) {\n    // in Node.js or RingoJS v0.8.0+\n    if (moduleExports) factory(freeModule.exports);\n    // in Narwhal or RingoJS v0.7.0-\n    else factory(freeExports);\n  }\n  // in a browser or Rhino\n  else {\n    factory((root[name] = {}));\n  }\n}(this, 'luaparse', function (exports) {\n  'use strict';\n\n  exports.version = '0.2.1';\n\n  var input, options, length;\n\n  // Options can be set either globally on the parser object through\n  // defaultOptions, or during the parse call.\n  var defaultOptions = exports.defaultOptions = {\n    // Explicitly tell the parser when the input ends.\n      wait: false\n    // Store comments as an array in the chunk object.\n    , comments: true\n    // Track identifier scopes by adding an isLocal attribute to each\n    // identifier-node.\n    , scope: false\n    // Store location information on each syntax node as\n    // `loc: { start: { line, column }, end: { line, column } }`.\n    , locations: false\n    // Store the start and end character locations on each syntax node as\n    // `range: [start, end]`.\n    , ranges: false\n    // A callback which will be invoked when a syntax node has been completed.\n    // The node which has been created will be passed as the only parameter.\n    , onCreateNode: null\n    // A callback which will be invoked when a new scope is created.\n    , onCreateScope: null\n    // A callback which will be invoked when the current scope is destroyed.\n    , onDestroyScope: null\n  };\n\n  // The available tokens expressed as enum flags so they can be checked with\n  // bitwise operations.\n\n  var EOF = 1, StringLiteral = 2, Keyword = 4, Identifier = 8\n    , NumericLiteral = 16, Punctuator = 32, BooleanLiteral = 64\n    , NilLiteral = 128, VarargLiteral = 256;\n\n  exports.tokenTypes = { EOF: EOF, StringLiteral: StringLiteral\n    , Keyword: Keyword, Identifier: Identifier, NumericLiteral: NumericLiteral\n    , Punctuator: Punctuator, BooleanLiteral: BooleanLiteral\n    , NilLiteral: NilLiteral, VarargLiteral: VarargLiteral\n  };\n\n  // As this parser is a bit different from luas own, the error messages\n  // will be different in some situations.\n\n  var errors = exports.errors = {\n      unexpected: 'unexpected %1 \\'%2\\' near \\'%3\\''\n    , expected: '\\'%1\\' expected near \\'%2\\''\n    , expectedToken: '%1 expected near \\'%2\\''\n    , unfinishedString: 'unfinished string near \\'%1\\''\n    , malformedNumber: 'malformed number near \\'%1\\''\n    , invalidVar: 'invalid left-hand side of assignment near \\'%1\\''\n  };\n\n  // ### Abstract Syntax Tree\n  //\n  // The default AST structure is inspired by the Mozilla Parser API but can\n  // easily be customized by overriding these functions.\n\n  var ast = exports.ast = {\n      labelStatement: function(label) {\n      return {\n          type: 'LabelStatement'\n        , label: label\n      };\n    }\n\n    , breakStatement: function() {\n      return {\n          type: 'BreakStatement'\n      };\n    }\n\n    , gotoStatement: function(label) {\n      return {\n          type: 'GotoStatement'\n        , label: label\n      };\n    }\n\n    , returnStatement: function(args) {\n      return {\n          type: 'ReturnStatement'\n        , 'arguments': args\n      };\n    }\n\n    , ifStatement: function(clauses) {\n      return {\n          type: 'IfStatement'\n        , clauses: clauses\n      };\n    }\n    , ifClause: function(condition, body) {\n      return {\n          type: 'IfClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseifClause: function(condition, body) {\n      return {\n          type: 'ElseifClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseClause: function(body) {\n      return {\n          type: 'ElseClause'\n        , body: body\n      };\n    }\n\n    , whileStatement: function(condition, body) {\n      return {\n          type: 'WhileStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , doStatement: function(body) {\n      return {\n          type: 'DoStatement'\n        , body: body\n      };\n    }\n\n    , repeatStatement: function(condition, body) {\n      return {\n          type: 'RepeatStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , localStatement: function(variables, init) {\n      return {\n          type: 'LocalStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , assignmentStatement: function(variables, init) {\n      return {\n          type: 'AssignmentStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , callStatement: function(expression) {\n      return {\n          type: 'CallStatement'\n        , expression: expression\n      };\n    }\n\n    , functionStatement: function(identifier, parameters, isLocal, body) {\n      return {\n          type: 'FunctionDeclaration'\n        , identifier: identifier\n        , isLocal: isLocal\n        , parameters: parameters\n        , body: body\n      };\n    }\n\n    , forNumericStatement: function(variable, start, end, step, body) {\n      return {\n          type: 'ForNumericStatement'\n        , variable: variable\n        , start: start\n        , end: end\n        , step: step\n        , body: body\n      };\n    }\n\n    , forGenericStatement: function(variables, iterators, body) {\n      return {\n          type: 'ForGenericStatement'\n        , variables: variables\n        , iterators: iterators\n        , body: body\n      };\n    }\n\n    , chunk: function(body) {\n      return {\n          type: 'Chunk'\n        , body: body\n      };\n    }\n\n    , identifier: function(name) {\n      return {\n          type: 'Identifier'\n        , name: name\n      };\n    }\n\n    , literal: function(type, value, raw) {\n      type = (type === StringLiteral) ? 'StringLiteral'\n        : (type === NumericLiteral) ? 'NumericLiteral'\n        : (type === BooleanLiteral) ? 'BooleanLiteral'\n        : (type === NilLiteral) ? 'NilLiteral'\n        : 'VarargLiteral';\n\n      return {\n          type: type\n        , value: value\n        , raw: raw\n      };\n    }\n\n    , tableKey: function(key, value) {\n      return {\n          type: 'TableKey'\n        , key: key\n        , value: value\n      };\n    }\n    , tableKeyString: function(key, value) {\n      return {\n          type: 'TableKeyString'\n        , key: key\n        , value: value\n      };\n    }\n    , tableValue: function(value) {\n      return {\n          type: 'TableValue'\n        , value: value\n      };\n    }\n\n\n    , tableConstructorExpression: function(fields) {\n      return {\n          type: 'TableConstructorExpression'\n        , fields: fields\n      };\n    }\n    , binaryExpression: function(operator, left, right) {\n      var type = ('and' === operator || 'or' === operator) ?\n        'LogicalExpression' :\n        'BinaryExpression';\n\n      return {\n          type: type\n        , operator: operator\n        , left: left\n        , right: right\n      };\n    }\n    , unaryExpression: function(operator, argument) {\n      return {\n          type: 'UnaryExpression'\n        , operator: operator\n        , argument: argument\n      };\n    }\n    , memberExpression: function(base, indexer, identifier) {\n      return {\n          type: 'MemberExpression'\n        , indexer: indexer\n        , identifier: identifier\n        , base: base\n      };\n    }\n\n    , indexExpression: function(base, index) {\n      return {\n          type: 'IndexExpression'\n        , base: base\n        , index: index\n      };\n    }\n\n    , callExpression: function(base, args) {\n      return {\n          type: 'CallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , tableCallExpression: function(base, args) {\n      return {\n          type: 'TableCallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , stringCallExpression: function(base, argument) {\n      return {\n          type: 'StringCallExpression'\n        , base: base\n        , argument: argument\n      };\n    }\n\n    , comment: function(value, raw) {\n      return {\n          type: 'Comment'\n        , value: value\n        , raw: raw\n      };\n    }\n  };\n\n  // Wrap up the node object.\n\n  function finishNode(node) {\n    // Pop a `Marker` off the location-array and attach its location data.\n    if (trackLocations) {\n      var location = locations.pop();\n      location.complete();\n      if (options.locations) node.loc = location.loc;\n      if (options.ranges) node.range = location.range;\n    }\n    if (options.onCreateNode) options.onCreateNode(node);\n    return node;\n  }\n\n\n  // Helpers\n  // -------\n\n  var slice = Array.prototype.slice\n    , toString = Object.prototype.toString\n    , indexOf = function indexOf(array, element) {\n      for (var i = 0, length = array.length; i < length; i++) {\n        if (array[i] === element) return i;\n      }\n      return -1;\n    };\n\n  // Iterate through an array of objects and return the index of an object\n  // with a matching property.\n\n  function indexOfObject(array, property, element) {\n    for (var i = 0, length = array.length; i < length; i++) {\n      if (array[i][property] === element) return i;\n    }\n    return -1;\n  }\n\n  // A sprintf implementation using %index (beginning at 1) to input\n  // arguments in the format string.\n  //\n  // Example:\n  //\n  //     // Unexpected function in token\n  //     sprintf('Unexpected %2 in %1.', 'token', 'function');\n\n  function sprintf(format) {\n    var args = slice.call(arguments, 1);\n    format = format.replace(/%(\\d)/g, function (match, index) {\n      return '' + args[index - 1] || '';\n    });\n    return format;\n  }\n\n  // Returns a new object with the properties from all objectes passed as\n  // arguments. Last argument takes precedence.\n  //\n  // Example:\n  //\n  //     this.options = extend(options, { output: false });\n\n  function extend() {\n    var args = slice.call(arguments)\n      , dest = {}\n      , src, prop;\n\n    for (var i = 0, length = args.length; i < length; i++) {\n      src = args[i];\n      for (prop in src) if (src.hasOwnProperty(prop)) {\n        dest[prop] = src[prop];\n      }\n    }\n    return dest;\n  }\n\n  // ### Error functions\n\n  // #### Raise an exception.\n  //\n  // Raise an exception by passing a token, a string format and its paramters.\n  //\n  // The passed tokens location will automatically be added to the error\n  // message if it exists, if not it will default to the lexers current\n  // position.\n  //\n  // Example:\n  //\n  //     // [1:0] expected [ near (\n  //     raise(token, \"expected %1 near %2\", '[', token.value);\n\n  function raise(token) {\n    var message = sprintf.apply(null, slice.call(arguments, 1))\n      , error, col;\n\n    if ('undefined' !== typeof token.line) {\n      col = token.range[0] - token.lineStart;\n      error = new SyntaxError(sprintf('[%1:%2] %3', token.line, col, message));\n      error.line = token.line;\n      error.index = token.range[0];\n      error.column = col;\n    } else {\n      col = index - lineStart + 1;\n      error = new SyntaxError(sprintf('[%1:%2] %3', line, col, message));\n      error.index = index;\n      error.line = line;\n      error.column = col;\n    }\n    throw error;\n  }\n\n  // #### Raise an unexpected token error.\n  //\n  // Example:\n  //\n  //     // expected <name> near '0'\n  //     raiseUnexpectedToken('<name>', token);\n\n  function raiseUnexpectedToken(type, token) {\n    raise(token, errors.expectedToken, type, token.value);\n  }\n\n  // #### Raise a general unexpected error\n  //\n  // Usage should pass either a token object or a symbol string which was\n  // expected. We can also specify a nearby token such as <eof>, this will\n  // default to the currently active token.\n  //\n  // Example:\n  //\n  //     // Unexpected symbol 'end' near '<eof>'\n  //     unexpected(token);\n  //\n  // If there's no token in the buffer it means we have reached <eof>.\n\n  function unexpected(found, near) {\n    if ('undefined' === typeof near) near = lookahead.value;\n    if ('undefined' !== typeof found.type) {\n      var type;\n      switch (found.type) {\n        case StringLiteral:   type = 'string';      break;\n        case Keyword:         type = 'keyword';     break;\n        case Identifier:      type = 'identifier';  break;\n        case NumericLiteral:  type = 'number';      break;\n        case Punctuator:      type = 'symbol';      break;\n        case BooleanLiteral:  type = 'boolean';     break;\n        case NilLiteral:\n          return raise(found, errors.unexpected, 'symbol', 'nil', near);\n      }\n      return raise(found, errors.unexpected, type, found.value, near);\n    }\n    return raise(found, errors.unexpected, 'symbol', found, near);\n  }\n\n  // Lexer\n  // -----\n  //\n  // The lexer, or the tokenizer reads the input string character by character\n  // and derives a token left-right. To be as efficient as possible the lexer\n  // prioritizes the common cases such as identifiers. It also works with\n  // character codes instead of characters as string comparisons was the\n  // biggest bottleneck of the parser.\n  //\n  // If `options.comments` is enabled, all comments encountered will be stored\n  // in an array which later will be appended to the chunk object. If disabled,\n  // they will simply be disregarded.\n  //\n  // When the lexer has derived a valid token, it will be returned as an object\n  // containing its value and as well as its position in the input string (this\n  // is always enabled to provide proper debug messages).\n  //\n  // `lex()` starts lexing and returns the following token in the stream.\n\n  var index\n    , token\n    , previousToken\n    , lookahead\n    , comments\n    , tokenStart\n    , line\n    , lineStart;\n\n  exports.lex = lex;\n\n  function lex() {\n    skipWhiteSpace();\n\n    // Skip comments beginning with --\n    while (45 === input.charCodeAt(index) &&\n           45 === input.charCodeAt(index + 1)) {\n      scanComment();\n      skipWhiteSpace();\n    }\n    if (index >= length) return {\n        type : EOF\n      , value: '<eof>'\n      , line: line\n      , lineStart: lineStart\n      , range: [index, index]\n    };\n\n    var charCode = input.charCodeAt(index)\n      , next = input.charCodeAt(index + 1);\n\n    // Memorize the range index where the token begins.\n    tokenStart = index;\n    if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();\n\n    switch (charCode) {\n      case 39: case 34: // '\"\n        return scanStringLiteral();\n\n      // 0-9\n      case 48: case 49: case 50: case 51: case 52: case 53:\n      case 54: case 55: case 56: case 57:\n        return scanNumericLiteral();\n\n      case 46: // .\n        // If the dot is followed by a digit it's a float.\n        if (isDecDigit(next)) return scanNumericLiteral();\n        if (46 === next) {\n          if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();\n          return scanPunctuator('..');\n        }\n        return scanPunctuator('.');\n\n      case 61: // =\n        if (61 === next) return scanPunctuator('==');\n        return scanPunctuator('=');\n\n      case 62: // >\n        if (61 === next) return scanPunctuator('>=');\n        if (62 === next) return scanPunctuator('>>');\n        return scanPunctuator('>');\n\n      case 60: // <\n        if (60 === next) return scanPunctuator('<<');\n        if (61 === next) return scanPunctuator('<=');\n        return scanPunctuator('<');\n\n      case 126: // ~\n        if (61 === next) return scanPunctuator('~=');\n        return scanPunctuator('~');\n\n      case 58: // :\n        if (58 === next) return scanPunctuator('::');\n        return scanPunctuator(':');\n\n      case 91: // [\n        // Check for a multiline string, they begin with [= or [[\n        if (91 === next || 61 === next) return scanLongStringLiteral();\n        return scanPunctuator('[');\n\n      case 47: // /\n        // Check for integer division op (//)\n        if (47 === next) return scanPunctuator('//');\n        return scanPunctuator('/');\n\n      // * ^ % , { } ] ( ) ; & # - + |\n      case 42: case 94: case 37: case 44: case 123: case 124: case 125:\n      case 93: case 40: case 41: case 59: case 38: case 35: case 45: case 43:\n        return scanPunctuator(input.charAt(index));\n    }\n\n    return unexpected(input.charAt(index));\n  }\n\n  // Whitespace has no semantic meaning in lua so simply skip ahead while\n  // tracking the encounted newlines. Any kind of eol sequence is counted as a\n  // single line.\n\n  function consumeEOL() {\n    var charCode = input.charCodeAt(index)\n      , peekCharCode = input.charCodeAt(index + 1);\n\n    if (isLineTerminator(charCode)) {\n      // Count \\n\\r and \\r\\n as one newline.\n      if (10 === charCode && 13 === peekCharCode) index++;\n      if (13 === charCode && 10 === peekCharCode) index++;\n      line++;\n      lineStart = ++index;\n\n      return true;\n    }\n    return false;\n  }\n\n  function skipWhiteSpace() {\n    while (index < length) {\n      var charCode = input.charCodeAt(index);\n      if (isWhiteSpace(charCode)) {\n        index++;\n      } else if (!consumeEOL()) {\n        break;\n      }\n    }\n  }\n\n  // Identifiers, keywords, booleans and nil all look the same syntax wise. We\n  // simply go through them one by one and defaulting to an identifier if no\n  // previous case matched.\n\n  function scanIdentifierOrKeyword() {\n    var value, type;\n\n    // Slicing the input string is prefered before string concatenation in a\n    // loop for performance reasons.\n    while (isIdentifierPart(input.charCodeAt(++index)));\n    value = input.slice(tokenStart, index);\n\n    // Decide on the token type and possibly cast the value.\n    if (isKeyword(value)) {\n      type = Keyword;\n    } else if ('true' === value || 'false' === value) {\n      type = BooleanLiteral;\n      value = ('true' === value);\n    } else if ('nil' === value) {\n      type = NilLiteral;\n      value = null;\n    } else {\n      type = Identifier;\n    }\n\n    return {\n        type: type\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Once a punctuator reaches this function it should already have been\n  // validated so we simply return it as a token.\n\n  function scanPunctuator(value) {\n    index += value.length;\n    return {\n        type: Punctuator\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // A vararg literal consists of three dots.\n\n  function scanVarargLiteral() {\n    index += 3;\n    return {\n        type: VarargLiteral\n      , value: '...'\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Find the string literal by matching the delimiter marks used.\n\n  function scanStringLiteral() {\n    var delimiter = input.charCodeAt(index++)\n      , stringStart = index\n      , string = ''\n      , charCode;\n\n    while (index < length) {\n      charCode = input.charCodeAt(index++);\n      if (delimiter === charCode) break;\n      if (92 === charCode) { // \\\n        string += input.slice(stringStart, index - 1) + readEscapeSequence();\n        stringStart = index;\n      }\n      // EOF or `\\n` terminates a string literal. If we haven't found the\n      // ending delimiter by now, raise an exception.\n      else if (index >= length || isLineTerminator(charCode)) {\n        string += input.slice(stringStart, index - 1);\n        raise({}, errors.unfinishedString, string + String.fromCharCode(charCode));\n      }\n    }\n    string += input.slice(stringStart, index - 1);\n\n    return {\n        type: StringLiteral\n      , value: string\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Expect a multiline string literal and return it as a regular string\n  // literal, if it doesn't validate into a valid multiline string, throw an\n  // exception.\n\n  function scanLongStringLiteral() {\n    var string = readLongString();\n    // Fail if it's not a multiline literal.\n    if (false === string) raise(token, errors.expected, '[', token.value);\n\n    return {\n        type: StringLiteral\n      , value: string\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Numeric literals will be returned as floating-point numbers instead of\n  // strings. The raw value should be retrieved from slicing the input string\n  // later on in the process.\n  //\n  // If a hexadecimal number is encountered, it will be converted.\n\n  function scanNumericLiteral() {\n    var character = input.charAt(index)\n      , next = input.charAt(index + 1);\n\n    var value = ('0' === character && 'xX'.indexOf(next || null) >= 0) ?\n      readHexLiteral() : readDecLiteral();\n\n    return {\n        type: NumericLiteral\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Lua hexadecimals have an optional fraction part and an optional binary\n  // exoponent part. These are not included in JavaScript so we will compute\n  // all three parts separately and then sum them up at the end of the function\n  // with the following algorithm.\n  //\n  //     Digit := toDec(digit)\n  //     Fraction := toDec(fraction) / 16 ^ fractionCount\n  //     BinaryExp := 2 ^ binaryExp\n  //     Number := ( Digit + Fraction ) * BinaryExp\n\n  function readHexLiteral() {\n    var fraction = 0 // defaults to 0 as it gets summed\n      , binaryExponent = 1 // defaults to 1 as it gets multiplied\n      , binarySign = 1 // positive\n      , digit, fractionStart, exponentStart, digitStart;\n\n    digitStart = index += 2; // Skip 0x part\n\n    // A minimum of one hex digit is required.\n    if (!isHexDigit(input.charCodeAt(index)))\n      raise({}, errors.malformedNumber, input.slice(tokenStart, index));\n\n    while (isHexDigit(input.charCodeAt(index))) index++;\n    // Convert the hexadecimal digit to base 10.\n    digit = parseInt(input.slice(digitStart, index), 16);\n\n    // Fraction part i optional.\n    if ('.' === input.charAt(index)) {\n      fractionStart = ++index;\n\n      while (isHexDigit(input.charCodeAt(index))) index++;\n      fraction = input.slice(fractionStart, index);\n\n      // Empty fraction parts should default to 0, others should be converted\n      // 0.x form so we can use summation at the end.\n      fraction = (fractionStart === index) ? 0\n        : parseInt(fraction, 16) / Math.pow(16, index - fractionStart);\n    }\n\n    // Binary exponents are optional\n    if ('pP'.indexOf(input.charAt(index) || null) >= 0) {\n      index++;\n\n      // Sign part is optional and defaults to 1 (positive).\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0)\n        binarySign = ('+' === input.charAt(index++)) ? 1 : -1;\n\n      exponentStart = index;\n\n      // The binary exponent sign requires a decimal digit.\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise({}, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) index++;\n      binaryExponent = input.slice(exponentStart, index);\n\n      // Calculate the binary exponent of the number.\n      binaryExponent = Math.pow(2, binaryExponent * binarySign);\n    }\n\n    return (digit + fraction) * binaryExponent;\n  }\n\n  // Decimal numbers are exactly the same in Lua and in JavaScript, because of\n  // this we check where the token ends and then parse it with native\n  // functions.\n\n  function readDecLiteral() {\n    while (isDecDigit(input.charCodeAt(index))) index++;\n    // Fraction part is optional\n    if ('.' === input.charAt(index)) {\n      index++;\n      // Fraction part defaults to 0\n      while (isDecDigit(input.charCodeAt(index))) index++;\n    }\n    // Exponent part is optional.\n    if ('eE'.indexOf(input.charAt(index) || null) >= 0) {\n      index++;\n      // Sign part is optional.\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0) index++;\n      // An exponent is required to contain at least one decimal digit.\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise({}, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) index++;\n    }\n\n    return parseFloat(input.slice(tokenStart, index));\n  }\n\n\n  // Translate escape sequences to the actual characters.\n\n  function readEscapeSequence() {\n    var sequenceStart = index;\n    switch (input.charAt(index)) {\n      // Lua allow the following escape sequences.\n      // We don't escape the bell sequence.\n      case 'n': index++; return '\\n';\n      case 'r': index++; return '\\r';\n      case 't': index++; return '\\t';\n      case 'v': index++; return '\\x0B';\n      case 'b': index++; return '\\b';\n      case 'f': index++; return '\\f';\n      // Skips the following span of white-space.\n      case 'z': index++; skipWhiteSpace(); return '';\n      // Byte representation should for now be returned as is.\n      case 'x':\n        // \\xXX, where XX is a sequence of exactly two hexadecimal digits\n        if (isHexDigit(input.charCodeAt(index + 1)) &&\n            isHexDigit(input.charCodeAt(index + 2))) {\n          index += 3;\n          // Return it as is, without translating the byte.\n          return '\\\\' + input.slice(sequenceStart, index);\n        }\n        return '\\\\' + input.charAt(index++);\n      default:\n        // \\ddd, where ddd is a sequence of up to three decimal digits.\n        if (isDecDigit(input.charCodeAt(index))) {\n          while (isDecDigit(input.charCodeAt(++index)));\n          return '\\\\' + input.slice(sequenceStart, index);\n        }\n        // Simply return the \\ as is, it's not escaping any sequence.\n        return input.charAt(index++);\n    }\n  }\n\n  // Comments begin with -- after which it will be decided if they are\n  // multiline comments or not.\n  //\n  // The multiline functionality works the exact same way as with string\n  // literals so we reuse the functionality.\n\n  function scanComment() {\n    tokenStart = index;\n    index += 2; // --\n\n    var character = input.charAt(index)\n      , content = ''\n      , isLong = false\n      , commentStart = index\n      , lineStartComment = lineStart\n      , lineComment = line;\n\n    if ('[' === character) {\n      content = readLongString();\n      // This wasn't a multiline comment after all.\n      if (false === content) content = character;\n      else isLong = true;\n    }\n    // Scan until next line as long as it's not a multiline comment.\n    if (!isLong) {\n      while (index < length) {\n        if (isLineTerminator(input.charCodeAt(index))) break;\n        index++;\n      }\n      if (options.comments) content = input.slice(commentStart, index);\n    }\n\n    if (options.comments) {\n      var node = ast.comment(content, input.slice(tokenStart, index));\n\n      // `Marker`s depend on tokens available in the parser and as comments are\n      // intercepted in the lexer all location data is set manually.\n      if (options.locations) {\n        node.loc = {\n            start: { line: lineComment, column: tokenStart - lineStartComment }\n          , end: { line: line, column: index - lineStart }\n        };\n      }\n      if (options.ranges) {\n        node.range = [tokenStart, index];\n      }\n      if (options.onCreateNode) options.onCreateNode(node);\n      comments.push(node);\n    }\n  }\n\n  // Read a multiline string by calculating the depth of `=` characters and\n  // then appending until an equal depth is found.\n\n  function readLongString() {\n    var level = 0\n      , content = ''\n      , terminator = false\n      , character, stringStart;\n\n    index++; // [\n\n    // Calculate the depth of the comment.\n    while ('=' === input.charAt(index + level)) level++;\n    // Exit, this is not a long string afterall.\n    if ('[' !== input.charAt(index + level)) return false;\n\n    index += level + 1;\n\n    // If the first character is a newline, ignore it and begin on next line.\n    if (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n\n    stringStart = index;\n    while (index < length) {\n      // To keep track of line numbers run the `consumeEOL()` which increments\n      // its counter.\n      if (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n\n      character = input.charAt(index++);\n\n      // Once the delimiter is found, iterate through the depth count and see\n      // if it matches.\n      if (']' === character) {\n        terminator = true;\n        for (var i = 0; i < level; i++) {\n          if ('=' !== input.charAt(index + i)) terminator = false;\n        }\n        if (']' !== input.charAt(index + level)) terminator = false;\n      }\n\n      // We reached the end of the multiline string. Get out now.\n      if (terminator) break;\n    }\n    content += input.slice(stringStart, index - 1);\n    index += level + 1;\n\n    return content;\n  }\n\n  // ## Lex functions and helpers.\n\n  // Read the next token.\n  //\n  // This is actually done by setting the current token to the lookahead and\n  // reading in the new lookahead token.\n\n  function next() {\n    previousToken = token;\n    token = lookahead;\n    lookahead = lex();\n  }\n\n  // Consume a token if its value matches. Once consumed or not, return the\n  // success of the operation.\n\n  function consume(value) {\n    if (value === token.value) {\n      next();\n      return true;\n    }\n    return false;\n  }\n\n  // Expect the next token value to match. If not, throw an exception.\n\n  function expect(value) {\n    if (value === token.value) next();\n    else raise(token, errors.expected, value, token.value);\n  }\n\n  // ### Validation functions\n\n  function isWhiteSpace(charCode) {\n    return 9 === charCode || 32 === charCode || 0xB === charCode || 0xC === charCode;\n  }\n\n  function isLineTerminator(charCode) {\n    return 10 === charCode || 13 === charCode;\n  }\n\n  function isDecDigit(charCode) {\n    return charCode >= 48 && charCode <= 57;\n  }\n\n  function isHexDigit(charCode) {\n    return (charCode >= 48 && charCode <= 57) || (charCode >= 97 && charCode <= 102) || (charCode >= 65 && charCode <= 70);\n  }\n\n  // From [Lua 5.2](http://www.lua.org/manual/5.2/manual.html#8.1) onwards\n  // identifiers cannot use locale-dependet letters.\n\n  function isIdentifierStart(charCode) {\n    return (charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode;\n  }\n\n  function isIdentifierPart(charCode) {\n    return (charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode || (charCode >= 48 && charCode <= 57);\n  }\n\n  // [3.1 Lexical Conventions](http://www.lua.org/manual/5.2/manual.html#3.1)\n  //\n  // `true`, `false` and `nil` will not be considered keywords, but literals.\n\n  function isKeyword(id) {\n    switch (id.length) {\n      case 2:\n        return 'do' === id || 'if' === id || 'in' === id || 'or' === id;\n      case 3:\n        return 'and' === id || 'end' === id || 'for' === id || 'not' === id;\n      case 4:\n        return 'else' === id || 'goto' === id || 'then' === id;\n      case 5:\n        return 'break' === id || 'local' === id || 'until' === id || 'while' === id;\n      case 6:\n        return 'elseif' === id || 'repeat' === id || 'return' === id;\n      case 8:\n        return 'function' === id;\n    }\n    return false;\n  }\n\n  function isUnary(token) {\n    if (Punctuator === token.type) return '#-~'.indexOf(token.value) >= 0;\n    if (Keyword === token.type) return 'not' === token.value;\n    return false;\n  }\n\n  // @TODO this needs to be rethought.\n  function isCallExpression(expression) {\n    switch (expression.type) {\n      case 'CallExpression':\n      case 'TableCallExpression':\n      case 'StringCallExpression':\n        return true;\n    }\n    return false;\n  }\n\n  // Check if the token syntactically closes a block.\n\n  function isBlockFollow(token) {\n    if (EOF === token.type) return true;\n    if (Keyword !== token.type) return false;\n    switch (token.value) {\n      case 'else': case 'elseif':\n      case 'end': case 'until':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // Scope\n  // -----\n\n  // Store each block scope as a an array of identifier names. Each scope is\n  // stored in an FILO-array.\n  var scopes\n    // The current scope index\n    , scopeDepth\n    // A list of all global identifier nodes.\n    , globals;\n\n  // Create a new scope inheriting all declarations from the previous scope.\n  function createScope() {\n    var scope = Array.apply(null, scopes[scopeDepth++]);\n    scopes.push(scope);\n    if (options.onCreateScope) options.onCreateScope();\n  }\n\n  // Exit and remove the current scope.\n  function destroyScope() {\n    var scope = scopes.pop();\n    scopeDepth--;\n    if (options.onDestroyScope) options.onDestroyScope();\n  }\n\n  // Add identifier name to the current scope if it doesnt already exist.\n  function scopeIdentifierName(name) {\n    if (-1 !== indexOf(scopes[scopeDepth], name)) return;\n    scopes[scopeDepth].push(name);\n  }\n\n  // Add identifier to the current scope\n  function scopeIdentifier(node) {\n    scopeIdentifierName(node.name);\n    attachScope(node, true);\n  }\n\n  // Attach scope information to node. If the node is global, store it in the\n  // globals array so we can return the information to the user.\n  function attachScope(node, isLocal) {\n    if (!isLocal && -1 === indexOfObject(globals, 'name', node.name))\n      globals.push(node);\n\n    node.isLocal = isLocal;\n  }\n\n  // Is the identifier name available in this scope.\n  function scopeHasName(name) {\n    return (-1 !== indexOf(scopes[scopeDepth], name));\n  }\n\n  // Location tracking\n  // -----------------\n  //\n  // Locations are stored in FILO-array as a `Marker` object consisting of both\n  // `loc` and `range` data. Once a `Marker` is popped off the list an end\n  // location is added and the data is attached to a syntax node.\n\n  var locations = []\n    , trackLocations;\n\n  function createLocationMarker() {\n    return new Marker(token);\n  }\n\n  function Marker(token) {\n    if (options.locations) {\n      this.loc = {\n          start: {\n            line: token.line\n          , column: token.range[0] - token.lineStart\n        }\n        , end: {\n            line: 0\n          , column: 0\n        }\n      };\n    }\n    if (options.ranges) this.range = [token.range[0], 0];\n  }\n\n  // Complete the location data stored in the `Marker` by adding the location\n  // of the *previous token* as an end location.\n  Marker.prototype.complete = function() {\n    if (options.locations) {\n      this.loc.end.line = previousToken.line;\n      this.loc.end.column = previousToken.range[1] - previousToken.lineStart;\n    }\n    if (options.ranges) {\n      this.range[1] = previousToken.range[1];\n    }\n  };\n\n  // Create a new `Marker` and add it to the FILO-array.\n  function markLocation() {\n    if (trackLocations) locations.push(createLocationMarker());\n  }\n\n  // Push an arbitrary `Marker` object onto the FILO-array.\n  function pushLocation(marker) {\n    if (trackLocations) locations.push(marker);\n  }\n\n  // Parse functions\n  // ---------------\n\n  // Chunk is the main program object. Syntactically it's the same as a block.\n  //\n  //     chunk ::= block\n\n  function parseChunk() {\n    next();\n    markLocation();\n    if (options.scope) createScope();\n    var body = parseBlock();\n    if (options.scope) destroyScope();\n    if (EOF !== token.type) unexpected(token);\n    // If the body is empty no previousToken exists when finishNode runs.\n    if (trackLocations && !body.length) previousToken = token;\n    return finishNode(ast.chunk(body));\n  }\n\n  // A block contains a list of statements with an optional return statement\n  // as its last statement.\n  //\n  //     block ::= {stat} [retstat]\n\n  function parseBlock(terminator) {\n    var block = []\n      , statement;\n\n    while (!isBlockFollow(token)) {\n      // Return has to be the last statement in a block.\n      if ('return' === token.value) {\n        block.push(parseStatement());\n        break;\n      }\n      statement = parseStatement();\n      // Statements are only added if they are returned, this allows us to\n      // ignore some statements, such as EmptyStatement.\n      if (statement) block.push(statement);\n    }\n\n    // Doesn't really need an ast node\n    return block;\n  }\n\n  // There are two types of statements, simple and compound.\n  //\n  //     statement ::= break | goto | do | while | repeat | return\n  //          | if | for | function | local | label | assignment\n  //          | functioncall | ';'\n\n  function parseStatement() {\n    markLocation();\n    if (Keyword === token.type) {\n      switch (token.value) {\n        case 'local':    next(); return parseLocalStatement();\n        case 'if':       next(); return parseIfStatement();\n        case 'return':   next(); return parseReturnStatement();\n        case 'function': next();\n          var name = parseFunctionName();\n          return parseFunctionDeclaration(name);\n        case 'while':    next(); return parseWhileStatement();\n        case 'for':      next(); return parseForStatement();\n        case 'repeat':   next(); return parseRepeatStatement();\n        case 'break':    next(); return parseBreakStatement();\n        case 'do':       next(); return parseDoStatement();\n        case 'goto':     next(); return parseGotoStatement();\n      }\n    }\n\n    if (Punctuator === token.type) {\n      if (consume('::')) return parseLabelStatement();\n    }\n    // Assignments memorizes the location and pushes it manually for wrapper\n    // nodes. Additionally empty `;` statements should not mark a location.\n    if (trackLocations) locations.pop();\n\n    // When a `;` is encounted, simply eat it without storing it.\n    if (consume(';')) return;\n\n    return parseAssignmentOrCallStatement();\n  }\n\n  // ## Statements\n\n  //     label ::= '::' Name '::'\n\n  function parseLabelStatement() {\n    var name = token.value\n      , label = parseIdentifier();\n\n    if (options.scope) {\n      scopeIdentifierName('::' + name + '::');\n      attachScope(label, true);\n    }\n\n    expect('::');\n    return finishNode(ast.labelStatement(label));\n  }\n\n  //     break ::= 'break'\n\n  function parseBreakStatement() {\n    return finishNode(ast.breakStatement());\n  }\n\n  //     goto ::= 'goto' Name\n\n  function parseGotoStatement() {\n    var name = token.value\n      , label = parseIdentifier();\n\n    return finishNode(ast.gotoStatement(label));\n  }\n\n  //     do ::= 'do' block 'end'\n\n  function parseDoStatement() {\n    if (options.scope) createScope();\n    var body = parseBlock();\n    if (options.scope) destroyScope();\n    expect('end');\n    return finishNode(ast.doStatement(body));\n  }\n\n  //     while ::= 'while' exp 'do' block 'end'\n\n  function parseWhileStatement() {\n    var condition = parseExpectedExpression();\n    expect('do');\n    if (options.scope) createScope();\n    var body = parseBlock();\n    if (options.scope) destroyScope();\n    expect('end');\n    return finishNode(ast.whileStatement(condition, body));\n  }\n\n  //     repeat ::= 'repeat' block 'until' exp\n\n  function parseRepeatStatement() {\n    if (options.scope) createScope();\n    var body = parseBlock();\n    expect('until');\n    var condition = parseExpectedExpression();\n    if (options.scope) destroyScope();\n    return finishNode(ast.repeatStatement(condition, body));\n  }\n\n  //     retstat ::= 'return' [exp {',' exp}] [';']\n\n  function parseReturnStatement() {\n    var expressions = [];\n\n    if ('end' !== token.value) {\n      var expression = parseExpression();\n      if (null != expression) expressions.push(expression);\n      while (consume(',')) {\n        expression = parseExpectedExpression();\n        expressions.push(expression);\n      }\n      consume(';'); // grammar tells us ; is optional here.\n    }\n    return finishNode(ast.returnStatement(expressions));\n  }\n\n  //     if ::= 'if' exp 'then' block {elif} ['else' block] 'end'\n  //     elif ::= 'elseif' exp 'then' block\n\n  function parseIfStatement() {\n    var clauses = []\n      , condition\n      , body\n      , marker;\n\n    // IfClauses begin at the same location as the parent IfStatement.\n    // It ends at the start of `end`, `else`, or `elseif`.\n    if (trackLocations) {\n      marker = locations[locations.length - 1];\n      locations.push(marker);\n    }\n    condition = parseExpectedExpression();\n    expect('then');\n    if (options.scope) createScope();\n    body = parseBlock();\n    if (options.scope) destroyScope();\n    clauses.push(finishNode(ast.ifClause(condition, body)));\n\n    if (trackLocations) marker = createLocationMarker();\n    while (consume('elseif')) {\n      pushLocation(marker);\n      condition = parseExpectedExpression();\n      expect('then');\n      if (options.scope) createScope();\n      body = parseBlock();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.elseifClause(condition, body)));\n      if (trackLocations) marker = createLocationMarker();\n    }\n\n    if (consume('else')) {\n      // Include the `else` in the location of ElseClause.\n      if (trackLocations) {\n        marker = new Marker(previousToken);\n        locations.push(marker);\n      }\n      if (options.scope) createScope();\n      body = parseBlock();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.elseClause(body)));\n    }\n\n    expect('end');\n    return finishNode(ast.ifStatement(clauses));\n  }\n\n  // There are two types of for statements, generic and numeric.\n  //\n  //     for ::= Name '=' exp ',' exp [',' exp] 'do' block 'end'\n  //     for ::= namelist 'in' explist 'do' block 'end'\n  //     namelist ::= Name {',' Name}\n  //     explist ::= exp {',' exp}\n\n  function parseForStatement() {\n    var variable = parseIdentifier()\n      , body;\n\n    // The start-identifier is local.\n\n    if (options.scope) {\n      createScope();\n      scopeIdentifier(variable);\n    }\n\n    // If the first expression is followed by a `=` punctuator, this is a\n    // Numeric For Statement.\n    if (consume('=')) {\n      // Start expression\n      var start = parseExpectedExpression();\n      expect(',');\n      // End expression\n      var end = parseExpectedExpression();\n      // Optional step expression\n      var step = consume(',') ? parseExpectedExpression() : null;\n\n      expect('do');\n      body = parseBlock();\n      expect('end');\n      if (options.scope) destroyScope();\n\n      return finishNode(ast.forNumericStatement(variable, start, end, step, body));\n    }\n    // If not, it's a Generic For Statement\n    else {\n      // The namelist can contain one or more identifiers.\n      var variables = [variable];\n      while (consume(',')) {\n        variable = parseIdentifier();\n        // Each variable in the namelist is locally scoped.\n        if (options.scope) scopeIdentifier(variable);\n        variables.push(variable);\n      }\n      expect('in');\n      var iterators = [];\n\n      // One or more expressions in the explist.\n      do {\n        var expression = parseExpectedExpression();\n        iterators.push(expression);\n      } while (consume(','));\n\n      expect('do');\n      body = parseBlock();\n      expect('end');\n      if (options.scope) destroyScope();\n\n      return finishNode(ast.forGenericStatement(variables, iterators, body));\n    }\n  }\n\n  // Local statements can either be variable assignments or function\n  // definitions. If a function definition is found, it will be delegated to\n  // `parseFunctionDeclaration()` with the isLocal flag.\n  //\n  // This AST structure might change into a local assignment with a function\n  // child.\n  //\n  //     local ::= 'local' 'function' Name funcdecl\n  //        | 'local' Name {',' Name} ['=' exp {',' exp}]\n\n  function parseLocalStatement() {\n    var name;\n\n    if (Identifier === token.type) {\n      var variables = []\n        , init = [];\n\n      do {\n        name = parseIdentifier();\n\n        variables.push(name);\n      } while (consume(','));\n\n      if (consume('=')) {\n        do {\n          var expression = parseExpectedExpression();\n          init.push(expression);\n        } while (consume(','));\n      }\n\n      // Declarations doesn't exist before the statement has been evaluated.\n      // Therefore assignments can't use their declarator. And the identifiers\n      // shouldn't be added to the scope until the statement is complete.\n      if (options.scope) {\n        for (var i = 0, l = variables.length; i < l; i++) {\n          scopeIdentifier(variables[i]);\n        }\n      }\n\n      return finishNode(ast.localStatement(variables, init));\n    }\n    if (consume('function')) {\n      name = parseIdentifier();\n\n      if (options.scope) {\n        scopeIdentifier(name);\n        createScope();\n      }\n\n      // MemberExpressions are not allowed in local function statements.\n      return parseFunctionDeclaration(name, true);\n    } else {\n      raiseUnexpectedToken('<name>', token);\n    }\n  }\n\n  function validateVar(node) {\n    // @TODO we need something not dependent on the exact AST used. see also isCallExpression()\n    if (node.inParens || (['Identifier', 'MemberExpression', 'IndexExpression'].indexOf(node.type) === -1)) {\n      raise(token, errors.invalidVar, token.value);\n    }\n  }\n\n  //     assignment ::= varlist '=' explist\n  //     var ::= Name | prefixexp '[' exp ']' | prefixexp '.' Name\n  //     varlist ::= var {',' var}\n  //     explist ::= exp {',' exp}\n  //\n  //     call ::= callexp\n  //     callexp ::= prefixexp args | prefixexp ':' Name args\n\n  function parseAssignmentOrCallStatement() {\n    // Keep a reference to the previous token for better error messages in case\n    // of invalid statement\n    var previous = token\n      , expression, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n    expression = parsePrefixExpression();\n\n    if (null == expression) return unexpected(token);\n    if (',='.indexOf(token.value) >= 0) {\n      var variables = [expression]\n        , init = []\n        , exp;\n\n      validateVar(expression);\n      while (consume(',')) {\n        exp = parsePrefixExpression();\n        if (null == exp) raiseUnexpectedToken('<expression>', token);\n        validateVar(exp);\n        variables.push(exp);\n      }\n      expect('=');\n      do {\n        exp = parseExpectedExpression();\n        init.push(exp);\n      } while (consume(','));\n\n      pushLocation(marker);\n      return finishNode(ast.assignmentStatement(variables, init));\n    }\n    if (isCallExpression(expression)) {\n      pushLocation(marker);\n      return finishNode(ast.callStatement(expression));\n    }\n    // The prefix expression was neither part of an assignment or a\n    // callstatement, however as it was valid it's been consumed, so raise\n    // the exception on the previous token to provide a helpful message.\n    return unexpected(previous);\n  }\n\n\n\n  // ### Non-statements\n\n  //     Identifier ::= Name\n\n  function parseIdentifier() {\n    markLocation();\n    var identifier = token.value;\n    if (Identifier !== token.type) raiseUnexpectedToken('<name>', token);\n    next();\n    return finishNode(ast.identifier(identifier));\n  }\n\n  // Parse the functions parameters and body block. The name should already\n  // have been parsed and passed to this declaration function. By separating\n  // this we allow for anonymous functions in expressions.\n  //\n  // For local functions there's a boolean parameter which needs to be set\n  // when parsing the declaration.\n  //\n  //     funcdecl ::= '(' [parlist] ')' block 'end'\n  //     parlist ::= Name {',' Name} | [',' '...'] | '...'\n\n  function parseFunctionDeclaration(name, isLocal) {\n    var parameters = [];\n    expect('(');\n\n    // The declaration has arguments\n    if (!consume(')')) {\n      // Arguments are a comma separated list of identifiers, optionally ending\n      // with a vararg.\n      while (true) {\n        if (Identifier === token.type) {\n          var parameter = parseIdentifier();\n          // Function parameters are local.\n          if (options.scope) scopeIdentifier(parameter);\n\n          parameters.push(parameter);\n\n          if (consume(',')) continue;\n          else if (consume(')')) break;\n        }\n        // No arguments are allowed after a vararg.\n        else if (VarargLiteral === token.type) {\n          parameters.push(parsePrimaryExpression());\n          expect(')');\n          break;\n        } else {\n          raiseUnexpectedToken('<name> or \\'...\\'', token);\n        }\n      }\n    }\n\n    var body = parseBlock();\n    expect('end');\n    if (options.scope) destroyScope();\n\n    isLocal = isLocal || false;\n    return finishNode(ast.functionStatement(name, parameters, isLocal, body));\n  }\n\n  // Parse the function name as identifiers and member expressions.\n  //\n  //     Name {'.' Name} [':' Name]\n\n  function parseFunctionName() {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n    base = parseIdentifier();\n\n    if (options.scope) {\n      attachScope(base, scopeHasName(base.name));\n      createScope();\n    }\n\n    while (consume('.')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      base = finishNode(ast.memberExpression(base, '.', name));\n    }\n\n    if (consume(':')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      base = finishNode(ast.memberExpression(base, ':', name));\n      if (options.scope) scopeIdentifierName('self');\n    }\n\n    return base;\n  }\n\n  //     tableconstructor ::= '{' [fieldlist] '}'\n  //     fieldlist ::= field {fieldsep field} fieldsep\n  //     field ::= '[' exp ']' '=' exp | Name = 'exp' | exp\n  //\n  //     fieldsep ::= ',' | ';'\n\n  function parseTableConstructor() {\n    var fields = []\n      , key, value;\n\n    while (true) {\n      markLocation();\n      if (Punctuator === token.type && consume('[')) {\n        key = parseExpectedExpression();\n        expect(']');\n        expect('=');\n        value = parseExpectedExpression();\n        fields.push(finishNode(ast.tableKey(key, value)));\n      } else if (Identifier === token.type) {\n        if ('=' === lookahead.value) {\n          key = parseIdentifier();\n          next();\n          value = parseExpectedExpression();\n          fields.push(finishNode(ast.tableKeyString(key, value)));\n        } else {\n          value = parseExpectedExpression();\n          fields.push(finishNode(ast.tableValue(value)));\n        }\n      } else {\n        if (null == (value = parseExpression())) {\n          locations.pop();\n          break;\n        }\n        fields.push(finishNode(ast.tableValue(value)));\n      }\n      if (',;'.indexOf(token.value) >= 0) {\n        next();\n        continue;\n      }\n      break;\n    }\n    expect('}');\n    return finishNode(ast.tableConstructorExpression(fields));\n  }\n\n  // Expression parser\n  // -----------------\n  //\n  // Expressions are evaluated and always return a value. If nothing is\n  // matched null will be returned.\n  //\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\n  //\n  //     primary ::= nil | false | true | Number | String | '...'\n  //          | functiondef | tableconstructor\n  //\n  //     prefixexp ::= (Name | '(' exp ')' ) { '[' exp ']'\n  //          | '.' Name | ':' Name args | args }\n  //\n\n  function parseExpression() {\n    var expression = parseSubExpression(0);\n    return expression;\n  }\n\n  // Parse an expression expecting it to be valid.\n\n  function parseExpectedExpression() {\n    var expression = parseExpression();\n    if (null == expression) raiseUnexpectedToken('<expression>', token);\n    else return expression;\n  }\n\n\n  // Return the precedence priority of the operator.\n  //\n  // As unary `-` can't be distinguished from binary `-`, unary precedence\n  // isn't described in this table but in `parseSubExpression()` itself.\n  //\n  // As this function gets hit on every expression it's been optimized due to\n  // the expensive CompareICStub which took ~8% of the parse time.\n\n  function binaryPrecedence(operator) {\n    var charCode = operator.charCodeAt(0)\n      , length = operator.length;\n\n    if (1 === length) {\n      switch (charCode) {\n        case 94: return 12; // ^\n        case 42: case 47: case 37: return 10; // * / %\n        case 43: case 45: return 9; // + -\n        case 38: return 6; // &\n        case 126: return 5; // ~\n        case 124: return 4; // |\n        case 60: case 62: return 3; // < >\n      }\n    } else if (2 === length) {\n      switch (charCode) {\n        case 47: return 10; // //\n        case 46: return 8; // ..\n        case 60: case 62:\n            if('<<' === operator || '>>' === operator) return 7; // << >>\n            return 3; // <= >=\n        case 61: case 126: return 3; // == ~=\n        case 111: return 1; // or\n      }\n    } else if (97 === charCode && 'and' === operator) return 2;\n    return 0;\n  }\n\n  // Implement an operator-precedence parser to handle binary operator\n  // precedence.\n  //\n  // We use this algorithm because it's compact, it's fast and Lua core uses\n  // the same so we can be sure our expressions are parsed in the same manner\n  // without excessive amounts of tests.\n  //\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\n\n  function parseSubExpression(minPrecedence) {\n    var operator = token.value\n    // The left-hand side in binary operations.\n      , expression, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    // UnaryExpression\n    if (isUnary(token)) {\n      markLocation();\n      next();\n      var argument = parseSubExpression(10);\n      if (argument == null) raiseUnexpectedToken('<expression>', token);\n      expression = finishNode(ast.unaryExpression(operator, argument));\n    }\n    if (null == expression) {\n      // PrimaryExpression\n      expression = parsePrimaryExpression();\n\n      // PrefixExpression\n      if (null == expression) {\n        expression = parsePrefixExpression();\n      }\n    }\n    // This is not a valid left hand expression.\n    if (null == expression) return null;\n\n    var precedence;\n    while (true) {\n      operator = token.value;\n\n      precedence = (Punctuator === token.type || Keyword === token.type) ?\n        binaryPrecedence(operator) : 0;\n\n      if (precedence === 0 || precedence <= minPrecedence) break;\n      // Right-hand precedence operators\n      if ('^' === operator || '..' === operator) precedence--;\n      next();\n      var right = parseSubExpression(precedence);\n      if (null == right) raiseUnexpectedToken('<expression>', token);\n      // Push in the marker created before the loop to wrap its entirety.\n      if (trackLocations) locations.push(marker);\n      expression = finishNode(ast.binaryExpression(operator, expression, right));\n\n    }\n    return expression;\n  }\n\n  //     prefixexp ::= prefix {suffix}\n  //     prefix ::= Name | '(' exp ')'\n  //     suffix ::= '[' exp ']' | '.' Name | ':' Name args | args\n  //\n  //     args ::= '(' [explist] ')' | tableconstructor | String\n\n  function parsePrefixExpression() {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    // The prefix\n    if (Identifier === token.type) {\n      name = token.value;\n      base = parseIdentifier();\n      // Set the parent scope.\n      if (options.scope) attachScope(base, scopeHasName(name));\n    } else if (consume('(')) {\n      base = parseExpectedExpression();\n      expect(')');\n      base.inParens = true; // XXX: quick and dirty. needed for validateVar\n    } else {\n      return null;\n    }\n\n    // The suffix\n    var expression, identifier;\n    while (true) {\n      if (Punctuator === token.type) {\n        switch (token.value) {\n          case '[':\n            pushLocation(marker);\n            next();\n            expression = parseExpectedExpression();\n            base = finishNode(ast.indexExpression(base, expression));\n            expect(']');\n            break;\n          case '.':\n            pushLocation(marker);\n            next();\n            identifier = parseIdentifier();\n            base = finishNode(ast.memberExpression(base, '.', identifier));\n            break;\n          case ':':\n            pushLocation(marker);\n            next();\n            identifier = parseIdentifier();\n            base = finishNode(ast.memberExpression(base, ':', identifier));\n            // Once a : is found, this has to be a CallExpression, otherwise\n            // throw an error.\n            pushLocation(marker);\n            base = parseCallExpression(base);\n            break;\n          case '(': case '{': // args\n            pushLocation(marker);\n            base = parseCallExpression(base);\n            break;\n          default:\n            return base;\n        }\n      } else if (StringLiteral === token.type) {\n        pushLocation(marker);\n        base = parseCallExpression(base);\n      } else {\n        break;\n      }\n    }\n\n    return base;\n  }\n\n  //     args ::= '(' [explist] ')' | tableconstructor | String\n\n  function parseCallExpression(base) {\n    if (Punctuator === token.type) {\n      switch (token.value) {\n        case '(':\n          next();\n\n          // List of expressions\n          var expressions = [];\n          var expression = parseExpression();\n          if (null != expression) expressions.push(expression);\n          while (consume(',')) {\n            expression = parseExpectedExpression();\n            expressions.push(expression);\n          }\n\n          expect(')');\n          return finishNode(ast.callExpression(base, expressions));\n\n        case '{':\n          markLocation();\n          next();\n          var table = parseTableConstructor();\n          return finishNode(ast.tableCallExpression(base, table));\n      }\n    } else if (StringLiteral === token.type) {\n      return finishNode(ast.stringCallExpression(base, parsePrimaryExpression()));\n    }\n\n    raiseUnexpectedToken('function arguments', token);\n  }\n\n  //     primary ::= String | Numeric | nil | true | false\n  //          | functiondef | tableconstructor | '...'\n\n  function parsePrimaryExpression() {\n    var literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral\n      , value = token.value\n      , type = token.type\n      , marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    if (type & literals) {\n      pushLocation(marker);\n      var raw = input.slice(token.range[0], token.range[1]);\n      next();\n      return finishNode(ast.literal(type, value, raw));\n    } else if (Keyword === type && 'function' === value) {\n      pushLocation(marker);\n      next();\n      if (options.scope) createScope();\n      return parseFunctionDeclaration(null);\n    } else if (consume('{')) {\n      pushLocation(marker);\n      return parseTableConstructor();\n    }\n  }\n\n  // Parser\n  // ------\n\n  // Export the main parser.\n  //\n  //   - `wait` Hold parsing until end() is called. Defaults to false\n  //   - `comments` Store comments. Defaults to true.\n  //   - `scope` Track identifier scope. Defaults to false.\n  //   - `locations` Store location information. Defaults to false.\n  //   - `ranges` Store the start and end character locations. Defaults to\n  //     false.\n  //   - `onCreateNode` Callback which will be invoked when a syntax node is\n  //     created.\n  //   - `onCreateScope` Callback which will be invoked when a new scope is\n  //     created.\n  //   - `onDestroyScope` Callback which will be invoked when the current scope\n  //     is destroyed.\n  //\n  // Example:\n  //\n  //     var parser = require('luaparser');\n  //     parser.parse('i = 0');\n\n  exports.parse = parse;\n\n  function parse(_input, _options) {\n    if ('undefined' === typeof _options && 'object' === typeof _input) {\n      _options = _input;\n      _input = undefined;\n    }\n    if (!_options) _options = {};\n\n    input = _input || '';\n    options = extend(defaultOptions, _options);\n\n    // Rewind the lexer\n    index = 0;\n    line = 1;\n    lineStart = 0;\n    length = input.length;\n    // When tracking identifier scope, initialize with an empty scope.\n    scopes = [[]];\n    scopeDepth = 0;\n    globals = [];\n    locations = [];\n\n    if (options.comments) comments = [];\n    if (!options.wait) return end();\n    return exports;\n  }\n\n  // Write to the source code buffer without beginning the parse.\n  exports.write = write;\n\n  function write(_input) {\n    input += String(_input);\n    length = input.length;\n    return exports;\n  }\n\n  // Send an EOF and begin parsing.\n  exports.end = end;\n\n  function end(_input) {\n    if ('undefined' !== typeof _input) write(_input);\n\n    // Ignore shebangs.\n    if (input && input.substr(0, 2) === '#!') input = input.replace(/^.*/, function (line) {\n      return line.replace(/./g, ' ');\n    });\n\n    length = input.length;\n    trackLocations = options.locations || options.ranges;\n    // Initialize with a lookahead token.\n    lookahead = lex();\n\n    var chunk = parseChunk();\n    if (options.comments) chunk.comments = comments;\n    if (options.scope) chunk.globals = globals;\n\n    if (locations.length > 0)\n      throw new Error('Location tracking failed. This is most likely a bug in luaparse');\n\n    return chunk;\n  }\n\n}));\n/* vim: set sw=2 ts=2 et tw=79 : */\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n"],"names":[],"version":3,"file":"index.f2c0ec77.js.map","sourceRoot":"/__parcel_source_root/"}